# 2. MSQL进阶篇

## 01 存储引擎

###  （1）mysql体系结构

![](/mysql/1.png)

#### 【1】连接层

- 负责客户端和链接服务，涉及连接处理、认证授权等。该层还有连接池。

#### 【2】服务层 

- 完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解 析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。

#### 【3】引擎层

- 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。数据库中的索引是在存储引擎层实现的。这些引擎是可插拔的。

#### 【4】存储层

- 将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询 日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。

### （2）存储引擎简介

- 存储引擎是MYSQL核心部分，是**存储数据、建立索引、更新/查询数据**等技术的实现方式；
- 它是基于数据库表的，不是基于数据库的，存储引擎是表类型的；
- 创建表时可以指定存储引擎，在后面加上`ENGINE = InnoDB`即可；
- 查询当前数据库支持的存储引擎：`SHOW ENGINES;`；
- 查询表创建时的存储引擎：`SHOW CREATE TABLE XX;`；（默认是InnoDB）

### （3）存储引擎特点

#### 【1】InnoDB

- 介绍：高可靠性和高性能的通用执行引擎，MySQL默认执行引擎；

- 特点：（事务、行锁、外键约束）

  - DML操作遵循ACID模型，支持事务；
  - 行级锁，提高并发访问性能；
  - 支持外键约束，保证数据完整性和正确性。

- 文件：

  - xxx.ibd：xxx表示表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi【数据字典】）、数据和索引。
    - 参数：`innodb_file_per_table`（多张表是否共用一个表空间，MYSQL8.0是开启的，每张表对应一个表空间）
      - 查询该参数：`show variables like 'innodb_file_per_table'; ` 

- 逻辑存储结构：

  - 表空间： InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件；
  - 段：表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管 理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区；
  - 区：区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页；
  - 页：页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区；
  - 行：InnoDB存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段。

  ![](/mysql/2.png)

#### 【2】MyISAM

- 介绍：MySQL早期的默认存储引擎。
- 特点：
  - 不支持事务，不支持外键；
  - 支持表锁，不支持行锁；
  - 访问速度快。
- 文件：MYD、MYI、SDI文件。（数据、索引、表结构）

#### 【3】Memory

- 介绍：表表数据存储在内存中，智能作为临时表或缓存使用。
- 特点：内存存放、hash索引（默认）
- 文件：xx.sdi（表结构）

#### 【4】对比

![](/mysql/3.png)

#### 【5】InnoDB与MyISAM区别

- InnoDB支持事务，MyISAM不支持；
- InnoDB支持表锁和行锁，MyISAM只支持表锁，不支持行锁；
- InnoDB支持外键约束，MyISAM不支持。

### （4）存储引擎选择

- InnoDB：适合有事务需求、在并发情况下要求一致性、除查询外有大量增删改操作的应用场景；
- MyISAM：适合以读和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高的应用场景；
- MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。

## 02 索引

### （1）索引概述

- 用来高效获取数据的数据结构（有序）。该数据结构以某种方式引用（指向）数据，可实现快速查找【类比目录】；

- 无索引，即全表扫描。
- 索引优点：
  - 提高数据检索效率，降低数据库IO成本；
  - 通过索引对数据进行排序，江都数据排序成本，降低CPU消耗；
- 索引缺点：
  - 索引列占用空间；
  - 索引大大提高查询效率，但降低更新表的速度，对表进行增删改时，效率降低（要维护索引表）。

### （2）索引结构

- MySQL的索引在存储引擎层实现。

![](/mysql/4.png)

![](/mysql/5.png)

#### 【1】二叉树

- 缺点是顺序插入时，会形成一个链表，查询性能大大降低。大数据量情况下，层次较深，检索速度慢；（可能树的高度过大）

#### 【2】红黑树

- 大数据量情况下，层次较深，检索速度慢。（可能树的高度过大）

![](/mysql/6.png)

#### 【3】B-树（多路平衡二叉树）

- m阶B-数满足的条件：（阶是每个节点孩子节点的个数）
  - 每个节点最多有m个子节点，每个结点最多有m-1个关键字；
  - 除了根节点和叶子节点之外，其他的每个节点最少有m/2（向上取整）个孩子节点；
  - 根节点至少有两个孩子节点，即根结点最少有1个关键字；
  - 所有的叶子节点都在同一层；
  - 有k个子节点的父节点包含k - 1个关键码。
- m阶树添加操作时：会向上分裂。（[B-Tree Visualization (usfca.edu)](https://www.cs.usfca.edu/~galles/visualization/BTree.html)）
- TODO：B树与B+树内容待补充

![](/mysql/7.png)

#### 【4】B+树

- B+树与B树的区别：
  - 所有的数据出现在叶子结点，其他节点不保存数据，只用于索引；
  - 所有的叶子节点形成一个单向链表；
  - 如图：向上分裂时，3是数据会出现在叶子结点，也会作为索引放在根节点。

![](/mysql/8.png)

![](/mysql/9.png)

#### 【5】MySQL的B+树

- 在原B+Tree的基础上，所有叶子结点变成循环双向链表，提高区间访问的性能，利于排序；

![](/mysql/10.png)

#### 【6】Hash索引

- 采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中；
- hash冲突：多个键值映射到同一个槽位，可通过链表解决。

- 特点：
  - 存储时不按顺序，Hash索引只能用于对等比较(=，in)，不支持范围查询（between，>，< ，...）；
  - hash后结果是无序的，无法利用索引完成排序操作；
  - 查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引。
- 在MySQL中，支持hash索引的是Memory存储引擎。InnoDB中具有自适应hash功能，hash索引是 InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。

#### 【7】InnoDB选择B+树索引结构的原因

- 与二叉树相比，层数更低，搜索效率高；
- 与B-树相比，B-树的叶子结点与非叶子节点都会存储数据，导致一页中存储的键值变少，指针也跟着变少，同样要保存大量数据，就得增加树的高度，导致性能降低；MySQL的B+树还有个双向链表便于范围查找与排序；
- hash支持等值匹配，但不支持范围匹配和排序操作。

### （3）索引分类

#### 【1】索引分类

![](/mysql/11.png)

#### 【2】聚簇索引与非聚簇索引

- InnoDB存储引擎中，根据索引存储形式分为：

![](/mysql/12.png)

- 聚簇索引选取规则：
  - 如果存在主键，主键索引就是聚簇索引；
  - 不存在聚簇索引，就使用第一个唯一索引作为聚簇索引；
  - 表没有主键，且没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。

![](/mysql/13.png)

- 聚簇索引的叶子节点是该行的数据；
- 非聚簇索引的叶子节点挂的是该字段值对应的主键值。

![](/mysql/14.png)

- 该SQL执行过程：
  - 根据name字段进行查询，且name是一个非聚簇索引，先在非聚簇索引中找到Arm所对应的主键是10；
  - 由于查询的是*，则还需要根据主键值，在聚簇索引中找10对应的行（回表查询）；
  - 拿到该行数据，返回。
- 回表查询：先在非聚簇索引中查找数据，找到主键值，然后再到聚簇索引中根据主键值，获取数据。

### （4）索引语法

#### 【1】创建索引

```sql
CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name,... );

# 一般索引名是 idx_表名_字段1_字段2
create index idx_user_name on tb_user(name);
```

#### 【2】查看索引

```sql
SHOW INDEX FROM table_name;
```

#### 【3】删除索引

```sql
DROP INDEX index_name ON table_name;
```

### （5）SQL性能分析

#### 【1】SQL执行频率

- 可查看当前数据库增删查改的频次；
- 如果该数据库以增删改为主，我们可以考虑不对其进行索引的优化；
- 如果该数据库以查询为主，则要考虑对数据库索引进行优化。

```sql
 SHOW [SESSION|GLOBAL] STATUS LIKE 'Com_______'; # 7个_ 
```

![](/mysql/15.png)

#### 【2】慢查询日志

- 该日志记录所有执行时间操过指定参数（long_query_time，默认10s）的所有SQL语句的日志；
- MySQL慢查询日志默认关闭；
- 开启MySQL慢查询日志：

```sql
# 1. 修改配置文件（/etc/my.cnf））
# 开启MySQL慢日志查询开关
slow_query_log=1
# 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，该SQL语句就会被记录
long_query_time=2

# 2. 重启MySQL
systemctl restart mysqld

# 3. 重新登录MySQL查询
SHOW VARIABLES LIKE 'slow_query_log';
```

- 通过慢查询日志，可定位到执行效率比较低的SQL语句，并针对性进行优化。

#### 【3】profile详情

- 可以查看某个SQL语句具体执行过程中各阶段耗时情况；

```sql
# 1. 查询MySQL是否支持profile
SELECT @@hava_profiling;

# 2. 查询profile是否开启
SELECT @@profiling;

# 3. 开启profile（可加session/global级别）
SET @@profiling=1;

# 使用
# 执行一系列SQL语句后...
-- 查看每一条SQL的耗时情况（结果中有一列是query_id）
SHOW PROFILES;

-- 查看指定query_id的SQL语句各阶段耗时情况
SHOW PROFILE FOR QUERY query_id;

-- 查看指定query_id的SQL语句CPU的使用情况
SHOW PROFILE CPU  FOR QUERY query_id;
```

#### 【4】explain

- EXPLAIN或DESC可获取MySQL在执行SELECT语句时的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序。

  ```sql
  -- 直接在select语句前加explain或desc
  EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;
  ```

![](/mysql/16.png)

![](/mysql/17.png)

- id主要是嵌套查询时，好几个SELECT语句进行排序执行；
- type中：
  - system：只有一条数据的系统表或衍生表只能有一条数据的主查询；
  - const：仅仅能查出一条的SQL语句并且用于Primary key 或 unique索引；
  - eq_ref：对于每个索引键的查询，返回匹配唯一行数据（有且只有1个，不能多，不能0）【唯一索引、主键索引】;
  - ref：非唯一性索引：对于每个索引键的查询，返回匹配的所有行（可以是0，或多个）
  - range：检索指定范围的行，查找一个范围内的数据；
  - index：查询索引中的全部数据；
    - 比如查找索引列的值：`select name,id from student;`，name是常规索引，不回表查询
  - all：全表扫描。
  - filtered：查到的结果占查询过程中遍历的行数的百分比，越高越好。

### （6）索引使用

#### 【1】单列索引与联合索引

- 单列索引：一个索引只包含单个列；
- 联合索引：一个索引包含了多个列。（即在B+树中key值是多个列的值如(a,b)）
- 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引， 而非单列索引。

#### 【2】最左前缀法则

- 针对的联合索引；
- 最左前缀法则指的是查询从索引的最左列开始， 并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)，没有最左列就全部失效；
- 创建联合索引时，该索引为(a,b,c)：（创建索引先按a排序，再按b排序，最后按c排序）
  - 条件语句：`where a = xx`，只使用a索引，则索引只有(a)部分生效；
  - 条件语句：`where a = xx and b = xx`，使用a,b，则索引只有(a,b)部分生效，c失效；
  - 条件语句：`where a=xx and c = xx`，跳过了b列，则(a)生效，b,c部分失效；
  - 条件语句：`where b = xx and c =xx`，没有a列即没有最左列，索引全部失效。
  - 注意：a,b,c在where中顺序并不影响索引生效结果，`where a, b, c`与`where b,a,c`索引都为(a,b,c)；
- 一般把查询最频繁的列作为联合索引的最左列；

#### 【3】SQL提示

- 一句SQL语句执行时可能能走好几种索引，MySQL会自动选择一个索引进行查询，但有时候我们又需要指定走某个索引，就需要SQL提示；
- SQL提示：在SQL语句中加入一些人为的提示来达到优化操作的目的；

```sql
#  use index（建议该条语句走哪条索引，mysql内部还会再次进行评估）
explain select * from tb_user use index(idx_user_pro) where profession = '软件工程';

# ignore index（忽略指定的索引）
explain select * from tb_user ignore index(idx_user_pro) where profession = '软件工程';

# force index （强制使用某条索引）
explain select * from tb_user force index(idx_user_pro) where profession = '软件工程';
```

#### 【4】覆盖索引

- 覆盖索引：创建一个索引，该索引包含查询中用到的所有字段；（主要是为了避免回表查询）

- 尽量使用覆盖索引，减少select *；
- 查询的字段最好是索引的字段（可包含主键值），因为走非聚簇索引时，就可以查找到对应字段，还可以查询到索引字段以及叶子节点上的主键值；

- 如果查询的字段包含非索引的字段，则还会通过主键值到聚簇索引中进行回表查询。

- explain中Extra字段值解析：

![](/mysql/18.png)

#### 【5】前缀索引

- 主要针对字符串类型的字段作为索引，若都用原字符串作索引，会导致索引变得很大， 查询时，浪费大量的磁盘IO， 影响查询效率。因此可以把字符串的一部分前缀作为索引，节约索引空间，提高查询效率。
- 前缀长度根据选择性决定，选择性是指不重复的索引值（基数）和数据表的记录总数的比值，选择性越高查询效率越高，唯一索引的选择性为1；

```sql
create index idx_xxxx on 表名( 字段名(n));

# 计算选择性
select count(distinct email) / count(*) from tb_user ;
select count(distinct substring(email,1,5)) / count(*) from tb_user ;
```

### （7）索引失效情况

#### 【1】联合索引的最左前缀法则

- 没有遵循最左前缀法则， 如没有添加最左列作为条件就使用联合索引会失败；

#### 【2】联合索引中范围查找

- 联合索引中，出现范围查询(>,<)，范围查询右侧的列索引失效；
- 解释：联合索引（a,b,c）
  - 索引值：(1,1,4) (1,2,0) (1,2,1) (1,2,2)
  - `where a = 1 and b = 2 and c < 2`：索引是按a先排序，在b排序，在c排序，a,b都是等值，获得的结果是有序的，然后可以对c进行范围查找；
  - `where a= 1 and c < 2 and b = 2`：虽然c是范围查找放在中间，但效果同上，是要看索引创建时的顺序，而非where中的顺序；
  - `where a = 1 and b <=2 and c = 1`：先按a=1,b<=2查找结果，以上索引值都满足，但看c列(4,0,1,2)，变成无序，导致后面列索引失效；

#### 【3】在索引列上进行位列算

```sql
explain select * from tb_user where substring(phone,10,2) = '15';
```

#### 【4】字符串类型不加引号

```sql
explain select * from tb_user where phone = '17799990015';

# phone列的索引失效（MySQL会隐式转换找值）
explain select * from tb_user where phone = 17799990015;
```

#### 【5】模糊查询

- 尾部模糊匹配，索引不失效；
- 头部模糊匹配。索引失效。

#### 【6】or连接条件

- 用or分开的条件，条件中的字段都有索引，就不会失效；
- 用or分开的条件，有一方条件中字段不是索引，那么其他条件中的字段即使是索引也不会生效。

#### 【7】数据分布影响

- MySQL评估使用索引查询比全表查询慢，索引就会失效。
- 例如：is null 、is not null是否走索引，具体问题具体分析，看值的占比，分析哪个查询快。

### （8）索引设计原则

-  针对于数据量较大，且查询比较频繁的表建立索引；
- 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引；
- 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高；
- 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引；
-  尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间， 避免回表，提高查询效率；
- 控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率；
- 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。

