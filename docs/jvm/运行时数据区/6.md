01 栈、堆、方法区的交互关系

pic 18

pic 19

02 方法区的理解

- 方法区看做是一块独立于Java堆的内存空间，线程共享；（Non-Heap）
- 方法区在JVM启动时创建，可设置大小，其实际物理内存空间和Java对区一样可不连续；
- 方法区大小决定系统可保存多少类，若系统定义过多类，则会导致方法区溢出，OOM；
- 关闭JVM会释放该区域内存；
- 方法区是一种规范，**永久代和元空间是方法区的具体实现**；
- 永久代和元空间的最大区别：**元空间不在虚拟机设置的内存中，而是使用本地内存**

03 设置方法区大小与OOM

- 方法区大小设置

- jdk7及以前：
  - `-XX:PermSize`：设置永久代初始分配空间，默认20.75M
  - `-XX:MaxPermSize`：设置永久代最大可分配空间，32位机器模式默认64M，64位机器模式默认82M
  - OOM：OutOfMemoryError:PermGenspace
- jdk8及以后：
  - `-XX:MetaspaceSize`和`-XX:MaxMetaspaceSize`，前者默认值21M，后者-1即无限制
  - 使用系统内存，OOM：OutOfMemoryError:Metaspace
  - 初始化值时一个初始的高水位线，一旦触及该值，Full GC会被触发并卸载没用的类（即这些类的对应的类加载器不在存活），高水位线被重置，该新值取决于GC后释放了多少元空间。若释放的空间不足，则在不超过MaxMetaspaceSize时，适当提高该值；若释放空间过多，则适当降低该值；
  - 若初始化的高水位线设置过低，则上述高水位线频繁调整，Full GC会多次调用，则设置初始分配空间为一个较高的值。
- OOM的解决：
  - 通过对dump的堆转储快照进行分析，分析OOM原因是内存泄露（Memory Leak）还是内存溢出（Memory Overflow）
    - 内存泄露：程序在申请内存后，无法释放已申请的内存空间
      - 该对象不再使用本该被回收，但由于GC Roots仍然引用该对象，导致不能GC，一般而言是代码有问题，如IO流未关闭、ThreadLocal未remove；
      - 查看泄露对象到GC Roots的引用链，定位泄露代码的位置。
    - 内存溢出：程序在申请内存时，没有足够的内存空间供其使用
      - new的对象过多，但这些对象都有用，不能被GC，侧重于内存不够；
      - 适当提高虚拟机的堆参数和物理内存大小，从代码上查看某些对象生命周期是否过长、持有状态时间是否过长，尝试减少程序运行期的内存消耗。

04 方法区的内部结构

&emsp;&emsp;方法区存储已被虚拟机加载的**类型信息、常量、静态常量、即时编译器编译后的代码缓存等**。即**类型信息、运行时常量池、静态变量、JIT代码缓存、域信息、方法信息**。

&emsp;&emsp;类被加载到方法区时，在该类和对应的类加载器中会**彼此记录**双方，即该类记录是被谁加载的，类加载器记录了加载哪些类。

- 类型信息（类、接口、枚举、注解）：
  - 修饰符，完整有效名称（全名=包名.类名）
  - 直接父类的完整有效名（接口与Object类无父类）
  - 直接接口的一个有序列表
- 域信息：
  - 方法区保存类型的所有域的相关信息与域的声明顺序（即属性），方法信息同上
  - 域名称，域类型，域修饰符
- 方法信息：
  - 方法名，方法返回类型，方法的修饰符，方法参数数量与类型（按顺序）
  - 方法的字节码、操作数栈与局部变量表的大小（抽象方法和本地方法除外）
  - 异常表（抽象方法和本地方法除外）：每个异常处理的开始/结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引
  - 注：构造器在字节码文件中是`<init>`方法
- 静态变量（类变量）：
  - 静态变量和类关联，随着类的加载而加载，在链接阶段的准备阶段为静态变量赋零值，在初始化阶段进行显式初始化即`<clinit>`方法（该方法也是包含在方法信息中）
  - 类变量被类的所有实例共享，即使没有类实例，也可访问
- 全局常量：static final
  - 全局常量在编译时就被分配

```java
public class MethodAreaTest {
    public static void main(String[] args) {
        Order order = null;
        // 没有实例，都可访问（不可访问对象属性/方法）
        System.out.println(order.count); 
        order.hello();
        System.out.println(order.number);
    }
}

class Order {
    public static int count =1;
    public static final int number = 2;

    public static void hello() {
        System.out.println("hello");
    }
}
```

pic 20



05 方法区使用举例

06 方法区的演变细节

07 方法区的垃圾回收

08 总结