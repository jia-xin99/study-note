# 05 堆

## 堆的核心概述

- 一个Java程序对应一个进程，一个进程对应一个JVM实例，一个JVM实例有一个运行时数据区，一个运行时数据区只有一个方法区与堆；
- Java堆区在JVM启动时被创建，其空间大小也确定，堆内存大小可设置。是JVM管理的最大一块内存空间；
- 堆可以是物理上不连续的内存空间，在逻辑上是连续的内存空间，用于存储Java对象实例；
- 所有的线程共享Java堆，在堆上可划分线程私有的缓冲区（TLAB）【每个线程占一小块】。
- 《Java虚拟机规范》：所有对象实例以及数组都应当在运行时分配在堆上。【实际不一定】
- 数组和对象可能永远不会存储在栈上，栈帧中保存引用，该引用指向对象或数组在在堆中位置；
- 方法结束后，堆中对象不会马上移除，仅在GC时移除；
- 堆是GC执行垃圾回收的重点区域。
- 堆空间分为新生代和老年代，新生代分为Eden区与2个Survivor区【有1个为空】。

![](/jvm/1.png)

##  新生代和老年代

![](/jvm/2.png)

- JVM堆中Java对象分为2类：
  - 生命周期较短，其创建和消亡迅速；
  - 生命周期较长，在某些情况下与JV M生命周期一致。
- 堆区分区：
  - 新生代 ：新生代划分为Eden空间、Survivor0空间与Survivor1空间（from区与to区）。 
  - 老年代：存放新生代中经历多次GC后仍存活的对象。
- 新生代与老年代占比：
  - **默认情况1 : 2**，新生代占1/3，若许多Java对象生命周期较长就提高old比例；
- Eden区与Survivor区占比：
  - **默认：8 : 1 : 1**，默认情况下不一定为该比例，是有自适应比例，需要关闭自适应比例：`-XX:-UseAdaptiveSizePolicy`；
  - Eden区过大，则导致YGC失去作用，Major GC和Full GC次数增多；Eden区过小，则YGC过于频繁；
- 几乎所有Java对象在Eden区被new出来；
- 绝大部分Java对象销毁在新生代进行。

##  对象分配过程

1. new的对象先放在Eden区，该区有大小限制；
2. 当Eden区填满时，又要创建对象，则JVM垃圾回收器对Eden区进行Minor GC。将Eden区不再被其他对象引用的对象销毁，再加载新的对象到Eden区；
3. 将Eden区的剩余对象移动到幸存者0区，对象的次数（年龄）+1，1区为空（to区）；
4. 若Eden区满再次触发垃圾回收，将Eden区的未销毁的对象放在幸存者1区，幸存者0区中没被回收的对象移动到幸存者1区，次数（年龄）+1，0区为空（to区）；
5. 若Eden区满再次触发垃圾回收，则将Eden区和幸存者1区的没被回收的对象放在幸存者0区，次数（年龄）+1，1区为空（to区，1区和0区交替为空）；
6. 默认次数为15次，**若对象经历15次GC没被回收**或者**幸存者区满**（幸存者区部分对象）则晋升到Old区；
7. 当老年代内存不足时，再次触发GC：Major GC；
8. 若Major GC后，任无法进行对象的保存，则报错OOM。
- 总结：
  - Eden区满才触发Minor GC，s0或s1区满不会触发Minor GC；
  - 针对幸存者s0、s1区：复制之后有交换，谁空谁是to区；
  - 垃圾回收频繁在新生代收集，很少在老年代收集，几乎不在永久代/元空间收集。

![](/jvm/3.png)

## Minor GC、Major GC、Full GC

- GC按回收区域分为2类：
  - 部分收集（Partial GC）
    - 新生代收集（Minor GC/Young GC）
    - 老年代收集（Major GC/Old GC）
      - 目前，只有CMS GC有Major GC
      - 许多时候，Major GC与Full GC混淆使用
    - 混合收集（Mixed GC）：收集整个新生代和部分老年代
      - 目前，只有G1 GC会Mixed GC
  - 整堆收集（Full GC）：收集整个java堆和方法区。在开发或调优中尽量避免。
- GC触发条件：
  - Minor GC：
    - 新生代空间不足，指Eden区满，幸存者区满不会GC（每次GC会清理年轻代内存，包含幸存者区）；
    - 非常频繁，回收速度较快；
    - 会引发STW（stop the world），暂停其他用户的线程，GC结束，用户线程才恢复运行。
  - Major GC：
    - 出现Major GC，经常伴随至少一次Minor GC（非绝对，Parallel Scavenge收集器的收集策略中有直接进行Major GC的策略选择过程）；
      - 老年代空间不足，先尝试触发Minor GC，若还不足，则触发Major GC
    - Major GC速度比Minor GC慢，STW时间更长；
    - 若Major GC后内存仍不足，则OOM。
  - Full GC：
    - 调用`System.gc()`，系统建议执行Full GC，不必然执行；
    - 老年代空间不足或方法区空间不足，执行；
    - 通过Minor GC后进入老年代的平均大小大于老年代的可用内存，执行；
    - 由Eden区、From区向To区复制时，对象大小大于To区可用内存，则将该对象晋升到老年代，且老年代可用内存小于该对象大小，执行。

## 堆空间分带思想

> 为什么要把Java堆分代？不分代就不能正常工作？

&emsp;&emsp;不同对象生命周期不同，大部分对象是临时对象。不分代也可以，分代是为了优化GC性能。没分代，则需要对堆所有区域进行扫描。把生命周期不同的对象分代进行统一管理，对不同代采用不同GC算法，提高GC性能。

## 对象提升规则

- 若对象在Eden区出生，经历第一次Minor GC后仍存活且可被幸存者区容纳，则移动到幸存者区，对象年龄为1。对象在幸存者区每经历一次Minor GC且未被回收，则年龄+1，当年龄达到阈值（默认15）则晋升到老年代；
- 不同年龄段对象分配原则：
  - 优先分配到Eden
  - 大对象直接分配到老年代（尽量避免）
  - 长期存活对象分配到老年代
  - 动态对象年龄判断
    - 若幸存者区中相同年龄的所有对象大小总和大于幸存者空间的一半，年龄大于或等于该年龄的对象直接晋升到老年代，无需达到阈值；
  - 空间分配担保
    - 发送Minor GC前，JVM会检查老年代最大可用连续空间是否大于新生代所有总空间
      - 若大于，则此次Minor GC安全
      - 若小于，则JVM根据空间分配担保属性查看是否允许担保失败；
        - 若允许，则会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小
          - 若大于，则尝试Minor GC，有风险
          - 若小于，改为执行Full GC
        - 若不允许，则执行一次Full GC
    - JDK6 之后，只要老年代连续空间大小大于新生代对象总大小或历次晋升的平均大小进行Minor GC，否则进行Full GC。

##  线程本地分配缓存区：TLAB

> 为什么会有TLAB？

- 堆区是线程共享区域，任何线程都可访问到堆中共享数据；
- 对象实例创建在JVM中非常频繁，在并发环境下从堆中划分内存空间线程不安全；
- 避免多个线程操作同一地址（即在同一地址创建对象），需要使用加锁等机制，进行影响分配速度。

> 什么是TLAB？

- 从内存模型而不是垃圾回收角度，对Eden区继续进行划分，JVM为**每个线程分配一个私有区域**，包含在Eden区中（默认TLAB空间内存小），**创建是私有，访问是共享**。
- 多线程同时分配内存时，使用TLAB避免一系列的非线程安全问题，还能提升内存分配的吞吐量，该内存分配方式为**快速分配策略**。
- TLAB是内存分配首选，先在TLAB进行分配，若失败，则通过**加锁机制**确保数据原子性，在Eden空间分配内存。

![](/jvm/4.png)

## 堆不是分配对象的唯一选择

- JVM，对象在java堆中分配内存是常识；
- 若经过逃逸分析（相对耗时的）后发现，该对象并没有逃逸出方法，则可能优化成栈上分配，无需堆上分配内存，无需GC，减少GC次数。

### 【1】逃逸分析

- 逃逸分析的基本行为是分析对象动态作用域（new的对象是否可能在方法外被调用）：
  - 若一个对象在方法中new后，对象只在方法内部使用，则认为没发生逃逸；
  - 若一个对象在方法中new后，其被外部方法所引用，则认为发生逃逸；
    - eg1：为成员属性赋值（new），发生逃逸；
    - eg2：方法返回new的对象，发生逃逸；
    - eg3：new的对象，作为参数传给其他方法，发生逃逸。
- 没有发生逃逸的对象，则可分配在栈上，随着方法执行结束，栈帧出栈而销毁。
- 总结：开发中能使用局部变量的，不要在方法外定义。

### 【2】逃逸分类

- 方法逃逸：一个对象在方法内被new后，被外部方法所引用，例如作为参数传递到外部方法，这样此对象发生了逃逸；
- 线程逃逸：一个对象在方法内被new后，被外部线程访问，例如赋值给类变量或直接被其他线程访问，这样此对象发生了逃逸。

## 逃逸分析之代码优化

### 【1】栈上分配

- 堆分配转成栈分配。栈上分配可以支持未发生逃逸和方法逃逸，但不能支持线程逃逸。

### 【2】同步省略

- 若对象发现只能从一个线程访问到，则对该对象的操作可不考虑同步，即不用加锁。
	- JIT在编译时会通过逃逸分析判断同步块所使用的锁对象是否只能被一个线程访问而没发布到其他线程，则在编译该同步块时取消对这部分代码的同步，即同步省略，锁消除。
```java
public void f() {
　　Object hollis = new Object();
　　synchronized(hollis) {
　　　　System.out.println(hollis);
　　}
}

/*
	代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f()方法中，
	每个线程进入到方法f()时，都会创建一个hollis对象，
	并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉
*/
public void f() {
　　Object hollis = new Object();
       System.out.println(hollis);
}
```

### 【3】标量替换

- 在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。
  - eg：若对象拥有id和name两个字段，且不发生方法逃逸，则不需要创建对象，不用分配堆内存，而是将这两个字段视为局部变量进行分配
- 标量：一个数据已无法再分解成更小的数据来表示，如原始数据类型（int、long等数值类型及reference类型等）都不能再进一步分解；
- 聚合量：一个数据可以继续分解，如Java对象，其可分解为若干聚合量与标量。
  - eg：`class Student { String name; int age; School school; }`，name、age为标量，school为聚合量。
- **使用标量替换前提：开启逃逸分析，不允许对象逃逸出方法范围内。**可视为栈上分配的一种特例

## 设置堆内存大小与OOM

### 【1】堆空间大小设置

- `-Xms`：堆空间起始内存，`-X`为JVM运行参数，`ms`为memory start，同`-XX: InitialHeapSize`。
- `-Xmx`：堆空间最大内存，同`-XX: MaxHeapSize`，堆区中内存大小超过该值，会抛出OOM（OutOfMemoryError）异常。
- 通常`-Xms`与`-Xmx`两参数值相同，目的是能够在GC堆区后不需要重新计算堆区大小，从而提高性能

### 【2】默认堆空间大小

- 初始内存大小：物理电脑内存大小 / 64
- 最大内存大小：物理电脑内存大小 / 4

### 【3】查看设置的参数

- 方法1：终端`jps`查看进程号 -> `jstat -gc 进程id`
- 方法2：VM参数`-XX:+PrintGCDetails`

```java
public class HeapSpaceInitial {
    //VM参数：-Xms600m -Xmx600m
    public static void main(String[] args) {
        // Java虚拟机中堆内存总量
        // 设置600m，结果为580m，原因：只计算Eden+Old+S（只计算一个survivor区，因为必有一个幸存者区为空）
        long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;
        // Java虚拟机试图使用的最大堆内存量
        // 设置600m，结果为580m，原因：只计算Eden+Old+S（只计算一个survivor区，因为必有一个幸存者区为空）
        long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;
        System.out.println("initialMemory: " + initialMemory + "M");
        System.out.println("maxMemory: " + maxMemory + "M");
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

## 堆空间的参数设置

- `-XX:+PrintFlagsInitial`：查看所有参数默认初始值
- `-XX:+PrintFlagsFinal`：查看所有参数最终值
- `-XX:+PrintGCDetails`：输出详细的GC处理日志
- `-XX:+PrintGC`：打印gc简要信息
- `-Xms`：初始化堆空间大小
- `-Xmx`：最大堆空间大小
- `-Xmn`：新生代大小（初始值及最大值）
- `-XX:NewRatio=2`：老年代和新生代占比，默认2:1
  - 终端`jps` -> `jinfo -flag NewRatio 进程pid`查看设置情况
- `-XX:SurvivorRatio=8`：Eden区与Survivor区占比，默认8:1:1
  - 终端`jps` -> `jinfo -flag SurvivorRatio 进程pid`查看设置情况
- `-XX:MaxTenuringThreshold=<N>`设置对象晋升老年代的年龄阈值
- `-XX:UseTLAB`：设置是否开启TLAB空间，默认开启
  - 终端`jps` -> `jinfo -flag UseTLAB 进程号pid`：查看TLAB情况
- `-XX:TLABWasteTargetPercent`：设置TLAB空间所占Eden空间的百分比
- `-HandlePromotionFailue`：是否设置空间分配担保，已失效
- `-XX:+DoEscapeAnalysis`： 表示开启逃逸分析，默认开启
- `-XX:-DoEscapeAnalysis`： 表示关闭逃逸分析
- `-XX:+EliminateAllocations`：开启标量替换（默认开启），运行将对象打散分配在栈上（前提：开启逃逸分析）
- `-XX:+EliminateLocks`：开启同步消除（前提：开启逃逸分析）

## 总结

- 老年代放置长生命周期的对象，通常从幸存者区筛选拷贝过来的Java对象。特殊情况，对象会被分配在TLAB上；
- 若对象较大，JVM视图直接分配在Eden其他位置上；若过大，完全无法在新生带找到足够长的连续空间内存，则直接分配到老年代；
- 一般而言，MinorGC频率比MajorGC高。