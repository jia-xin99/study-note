# 4. 变量的线程安全分析

## 成员变量与静态变量是否线程安全

- 若都没共享，则线程安全
- 若都被共享，根据其状态是否改变，分为2种情况：
  - 若只是读操作，则线程安全
  - 若有读写操作，则读写操作这段代码是临界区，需要考虑线程安全

## 局部变量是否线程安全

- 局部变量是基本数据类型或包装类，则线程安全
- 但局部变量引用的对象不一定是线程安全：
  - 若对象没有逃离方法的作用访问，则线程安全
  - 若该对象逃离方法的作用范围，需要考虑线程安全
- 举例：
  - 类A中method1中有局部变量list且调用method2，后续还有对list的读写操作；
  - list作为mehod2的参数，然后method2中会对该参数的读写操作
  - 类A可被继承，method2不可被重写时（private）：method2没有新建线程，各个线程使用各自的list，不用考虑线程安全。
  - 类A可被继承，m2thod2可被重写时（public）：类B继承A，它重写method2，其中有新建线程来读写list参数的操作，就会导致原本调用method1的线程与method2新建的线程对list都有读写操作，则要考虑线程安全。
- 主要分析会不会出现多个线程对同一个对象（共享变量）有读写操作的情况。
- 私有和final在一定程度上可以保护线程安全。

## 常见线程安全类

### 【1】线程安全类

- String，Integer，StringBuffer，Random，Vector，Hashtable，java.util.concurent包下的类

### 【2】线程安全类的方法

- 线程安全类的方法都是原子性（多个线程调用同一实例的同一方法是线程安全）；
- 线程安全类的方法组合不是原子性的，即可能出现线程不安全的情况。

```java
Hashtable table = new Hashtable( );
// 线程1，线程2
if(table.get("key") == null) {
	table.put("key",value);
}
```

> 可能出现的情况：
> 	线程1执行get方法，线程2阻塞在get方法前；
> 	线程1执行完，释放锁，线程2和线程1同时抢锁，线程2可能抢到锁；
> 	线程2执行get方法，线程1阻塞在put方法前；
> 	线程2执行完，释放锁，线程2和线程1同时抢锁，二者都可抢到锁，然后会依次put。
> 	原本只想put一次key，目前put两次key，不是想要的结果。