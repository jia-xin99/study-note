# synchronized

## 介绍

- 阻塞式锁，俗称对象锁，使用互斥的方式使得同一时刻至多一个线程持有对象锁，其他线程再想获取该对象锁会阻塞，不用担心线程下文切换；
- synchronized使用对象锁保证临界区代码的原子性，临界区代码对外不可分割，不会被线程切换锁打断；
- synchronized可以使用

## 语法

### 【1】修饰代码块

- 线程1获得对象锁后，执行完临界区后会释放锁，并唤醒因同一对象锁阻塞的线程。

```java
synchronized(对象) { // 线程1获取对象锁，线程2（Blocked）
    临界区
}
```

### 【2】修饰实例方法

- 锁对象是某一具体类实例。

```java
    public void method1() {
        synchronized (this) {
            // 临界区
        }
    }
    // 等价于
    public synchronized void method2() {
        // 临界区
    }
```

【3】修饰静态方法

- 锁对象是当前class类。

```java
public class Test {
    public synchronized static void method() {
        // 临界区
    }
}
// 等价于
class Test {
    public void method() {
        synchronized (Test.class) {
            // 临界区
        }
    }
}   
```

## 面向对象写法

- 把保护的共享变量与对其的读写操作放在一个类中。

```java
class Room {
    int value = 0;

    public void increment() {
        synchronized (this) {
            value++;
        }
    }

    public void decrement() {
        synchronized (this) {
            value--;
        }
    }

    public void get() {
        // 加锁是避免类似MySQL的脏读
        synchronized (this) {
            return this.value;
        }
    }
}
```

::: details 测试代码

```java
public static void main(String[] args) {
    Room room = new Room();
    Thread t1 = new Thread(() -> {
        for (int i = 0; i < 500; i++) {
            room.increment();
        }
    }, "t1");
    Thread t2 = new Thread(() -> {
        for (int i = 0; i < 500; i++) {
            room.increment();
        }
    }, "t2");
    try {
        t1.start();
        t1.join();
        t2.join();
        // 获取到结果值：期望值 1000
        System.out.println(room.get());
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```

:::

