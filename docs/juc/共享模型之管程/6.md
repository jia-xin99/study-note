# 6. Java锁升级

## 轻量级锁

### 【1】说明

- 一个对象能被多线程访问，但多线程访问的时间是错开的（即无竞争），就可用轻量级锁来优化；
- 轻量级锁对使用者是透明的，语法仍然是synchronized。

### 【2】案例

```java
static final Object obj = new Object( );
public static void method1( ) {
    synchronized(obj) {
        // 同步块A
        method2( );
    }
}

public static void method2( ) {
    synchronized(obj) {
        // 同步块B
    }
}
```
- 创建锁记录（Lock Record）对象，每个线程的栈帧中都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word；
  ![](/juc/3.png)
- 让锁记录中Obecjt reference指向锁对象，并尝试使用CAS替换object（锁对象）的Mark Word，将Mark Word的状态由无锁变为轻量级锁状态，拿到锁的线程就会拿到锁对象的无锁状态；
  ![](/juc/4.png)
  - 如果CAS成功，则对象头中存储了锁记录地址和状态00（轻量级锁），表示由该线程对对象加锁。
    ![](/juc/5.png)
  - 如果CAS失败：
    - 情况1：如果是其他线程已经持有该Object的轻量级锁，则表明有竞争，进入锁膨胀过程（本线程拿不到锁）；
    - 情况2：如果是自己执行了synchronized**锁重入**，则再添加一条Lock Record表明重入的计数。
      ![](/juc/6.png)
- 当退出synchronized代码块（解锁）时，如有取值为null的锁记录，表明有重入，则重置锁记录，表明重入计数-1；
  ![](/juc/5.png)
- 当退出synchronized代码块（解锁）时，锁记录值不为null，会使用CAS将Mark Word恢复给对象（以轻量级锁去cas）；
  - 如果CAS成功，解除成功；
  - 如果CAS失败，说明Object对象的Mark Word已被竞争的线程（进不来）升级为重量级锁，则进入重量级锁的解锁流程；
  - 线程拿到了锁对象的无锁状态就表明该线程拥有锁。

### 【3】总结

- 加轻量级锁时，有竞争，若是自己则可重入；若是其他线程，则进入锁膨胀阶段，将锁升级为重量级锁，本线程进入EntryList队列（Blocked）；
- 释放轻量锁时，cas成功表明释放成功；cas失败表明锁被升级为重量级锁，则会去唤醒EntryList中的线程。

## 锁膨胀

### 【1】说明

- 添加轻量级锁cas失败时，有一种情况是其他线程为此对象加上了轻量级锁（有竞争），则需要锁膨胀，将轻量级锁升级为重量级锁。

### 【2】案例

- 当Thread-1进行轻量级加锁时，Thread-0已对该对象加了轻量级锁；

  ![](/juc/7.png)

- 此时Thread-1加轻量级锁失败，进入锁膨胀阶段；

  - 为Object对象申请Monitor对象，让Object指向重量级锁地址；

  - 自己进入Monitor的EntryList BLOCKED。

    ![](/juc/8.png)

- 当 Thread-0退出同步块解锁时，使用CAS将Mark Word的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照Monitor地址找到Monitor对象，设置Owner为null，唤醒EntryList中BLOCKED线程。

自旋锁（优化）

- 当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待（不会进入阻塞状态），然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环，当前线程可避免阻塞。
- 

偏向锁



