# 6. Java锁升级

## 轻量级锁

### 【1】说明

- 一个对象能被多线程访问，但多线程访问的时间是错开的（即无竞争），就可用轻量级锁来优化；
- 轻量级锁对使用者是透明的，语法仍然是synchronized；
- 轻量级锁不存在自旋。

### 【2】案例

```java
static final Object obj = new Object( );
public static void method1( ) {
    synchronized(obj) {
        // 同步块A
        method2( );
    }
}

public static void method2( ) {
    synchronized(obj) {
        // 同步块B
    }
}
```
- 创建锁记录（Lock Record）对象，每个线程的栈帧中都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word；
  ![](/juc/3.png)
- 让锁记录中Obecjt reference指向锁对象，并尝试使用CAS替换object（锁对象）的Mark Word，将Mark Word的状态由无锁变为轻量级锁状态，拿到锁的线程就会拿到锁对象的无锁状态；
  ![](/juc/4.png)
  - 如果CAS成功，则对象头中存储了锁记录地址和状态00（轻量级锁），表示由该线程对对象加锁。
    ![](/juc/5.png)
  - 如果CAS失败：
    - 情况1：如果是其他线程已经持有该Object的轻量级锁，则表明有竞争，进入锁膨胀过程（本线程拿不到锁）；
    - 情况2：如果是自己执行了synchronized**锁重入**，则再添加一条Lock Record表明重入的计数。
      ![](/juc/6.png)
- 当退出synchronized代码块（解锁）时，如有取值为null的锁记录，表明有重入，则重置锁记录，表明重入计数-1；
  ![](/juc/5.png)
- 当退出synchronized代码块（解锁）时，锁记录值不为null，会使用CAS将Mark Word恢复给对象（以轻量级锁去cas）；
  - 如果CAS成功，解除成功；
  - 如果CAS失败，说明Object对象的Mark Word已被竞争的线程（进不来）升级为重量级锁，则进入重量级锁的解锁流程；
  - 线程拿到了锁对象的无锁状态就表明该线程拥有锁。

### 【3】总结

- 加轻量级锁时，有竞争，若是自己则可重入；若是其他线程，则进入锁膨胀阶段，将锁升级为重量级锁，本线程进入EntryList队列（Blocked）；
- 释放轻量锁时，cas成功表明释放成功；cas失败表明锁被升级为重量级锁，则会去唤醒EntryList中的线程。

## 锁膨胀

### 【1】说明

- 添加轻量级锁cas失败时，有一种情况是其他线程为此对象加上了轻量级锁（有竞争），则需要锁膨胀，将轻量级锁升级为重量级锁。

### 【2】案例

- 当Thread-1进行轻量级加锁时，Thread-0已对该对象加了轻量级锁；
  ![](/juc/7.png)
- 此时Thread-1加轻量级锁失败，进入锁膨胀阶段；
  - 为Object对象申请Monitor对象，让Object指向重量级锁地址；
  - 自己进入Monitor的EntryList BLOCKED。
    ![](/juc/8.png)
- 当 Thread-0退出同步块解锁时，使用CAS将Mark Word的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照Monitor地址找到Monitor对象，设置Owner为null，唤醒EntryList中BLOCKED线程。

## 自旋锁

- 当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待（不会进入阻塞状态），然后不断的判断锁是否能够被成功获取（while），直到获取到锁才会退出循环，当前线程可避免阻塞。
- 自旋可不会使线程发生切换，一直处于运行状态，处于用户态；不会使线程进入阻塞状态，减少不必要的上下文切换，执行速度快；
- 自旋会占用CPU时间，自旋锁适合多核CPU并行执行；
- 为防止一直自旋占用CPU时间，可以设置自旋重试的次数阈值，达到就进入阻塞状态。

## 偏向锁

### 【1】介绍

- 轻量级锁在没有竞争的情况下，每次锁重入都需要CAS操作增加一条锁记录，可对此进行优化。
- 偏向锁就是在运行过程中，对象的锁偏向某个线程。只有第一次CAS把线程ID设置到对象的MarkWord头，之后还是该线程进行加锁，就不需要重新CAS，以后不发生竞争，该对象就归该线程。

### 【2】偏向状态

- 对象创建时，若开启偏向锁（默认），则对象创建后，其markword值后3位为101（偏向锁），其他值为0；
- 偏向锁默认延迟，不会在程序启动时立即生效，可VM参数配置修改；
- 若未开启偏向锁，则对象创建后3位为001（无锁状态），其hashcode、age都为0，第一次使用hashcode才赋值（延迟）。
- 处于偏向锁的对象解锁后，其线程id，仍存储在对象头中（便于以后偏向）；
- 可使用参数禁用偏向锁。

### 【3】偏向锁撤销

- 撤销不等同于释放，撤销是多个线程竞争导致不能再使用偏向模式（即撤销markword偏向位【第3位】）
- 使用对象的hashcode会撤销偏向锁，hashcode存在于无锁状态，之后再用该对象锁也不能回到偏向锁状态，如之前状态为无锁状态使用锁升级为轻量级锁，之前状态为偏向状态使用锁升级为重量级锁（相当于禁用偏向锁）；
  - 轻量级锁在锁记录中记录hashcode（交换）；
  - 重量级锁会在Monitor中记录hashcode。
- 其他线程使用对象，会将偏向锁升级为轻量级锁（注意：该两线程错开执行，否则是竞争升级为重量级锁），之后释放锁后恢复成无锁状态（不会变成偏向锁）；
- 调用wait/notify，wait、notify只有重量级锁有，都会升级为重量级锁。

### 【4】批量重定向

- 假设有线程A和B，线程A先执行，线程B等待A执行；线程A执行过程中对1个类的20个对象添加偏向锁；
- 线程B开始执行，依次使用前19个对象锁，锁的状态是：锁前偏向于A、锁中轻量级锁、锁后无锁状态（被撤销了19次）；
- 线程B开始使用第20个对象锁，由于达到了锁重定向的阈值（默认20），则锁的状态：锁前偏向于A、锁中偏向于B、锁后偏向于B。
- 当撤销一个类的偏向锁阈值达到20次后，jvm会认为偏向错误，会批量将后续对象重定向偏向于新的加锁线程。

### 【5】批量撤销

- 当撤销一个类的偏向锁阈值达到40次后，jvm会认为偏向错误，会把该类的所有对象以及要新建的对象都设置为不可偏向的。

## 锁消除

```java
public void method1{
	Object lock = new Object();
	synchronized(lock){
		x++;
	}
}
```

- 在即时编译期间，会通过逃逸分析，该锁不会被其他线程所共享，就可以消除这种没必要的锁；
- 该锁是局部变量，这个锁加上没有意义（未方法逃逸）。

```java
public void method1{
x++;
}
```

##   锁粗化

```java
public void method1{
	for(int i= 0;i<1000;i++){
		synchronized(lock){
			x++;
		}
	}
}
```

- 多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁，避免频繁的加锁解锁操作；
- 将以上循环中的每次加锁操作整合成一次循环外的锁请求。

```java
public void method1{
	synchronized(lock){
		for(int i= 0;i<1000;i++){
			x++;
		}
	}
}
```
