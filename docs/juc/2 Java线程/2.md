# 2. 常见方法

## start与run

- start是启动一个线程间接执行run方法，run方法是一个普通方法调用
- 同一个Thread对象start方法只可执行1次，否则会报错：`java.IllegalThreadStateException`

## sleep与yield

- sleep
  1. 当前线程状态：Runnig --> Timed Waiting（阻塞）
  2. 其他线程可用Interrupt方法打断正在睡眠的线程，此时sleep方法会抛`InterruptedException`
  3. 睡眠结束后的线程未必会立刻得到执行
  4. 建议用 TimeUnit 的 sleep 代替Thread的sleep来获得更好的可读性
- yield
  1. 让当前线程状态： Running --> Runnable（就绪）【就绪状态有机会被调度】
- 线程优先级
  1. 优先级级别：1-最小，5-常用，10-最大
  2. 不能真正控制线程调度，需要任务调度器

```java
    public static void main(String[] args) {
        Thread t = new Thread("t1") {
            @Override
            public void run() {
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    System.out.println(Thread.currentThread().getName() + "线程被打断");
                }
            }
        };

        t.start();

        try {
            TimeUnit.MILLISECONDS.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 打断
        t.interrupt();
    }
```

## join

- 线程1调用线程2的join方法，需要等到线程2完全执行完，线程1才可结束阻塞状态继续执行，适用于线程同步
- 底层是wait，细节后续有
- join(xx)：最多等待多少秒，等待结束线程2还未执行完，线程1可继续执行。线程结束该join也提前结束

```java
public class Test5Join {
    private static int r = 0;

    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(() -> {
            try {
                Thread.sleep(5000);
                r = 10;
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        });
        t.start();
        t.join();
        System.out.println(r); // 10
    }
}
```

## interrupt

- 打断sleep、wait、join的线程，会抛InterruptedException异常，对应线程会清空打断状态（false）
- 打断正常运行线程会设置打断状态即不会清空打断状态（true）
- 打断标记可用来安全停止一个线程
- park线程被打断，会设置打断状态
- 查询打断状态
  - isInterrupted( )：判断是否打断状态，不会清空打断状态
  - Interrupted( )：判断当前线程是否被打断，会清除打断状态 

## 其他方法

- isAlive( )：线程是否存活
- currentThread()：获取当前线程
- setName(String name)：设置线程名字
- getName( )：获取线程名字 
- getState()：获取线程状态
