import{_ as l}from"./12-2bed3019.js";import{_ as i,V as s,W as o,X as a,Y as t,Z as r,a0 as n,$ as c,C as _}from"./framework-b9c3f338.js";const d="/study-note/juc/13.png",u="/study-note/juc/14.png",h={},p=c('<h1 id="_4-线程状态" tabindex="-1"><a class="header-anchor" href="#_4-线程状态" aria-hidden="true">#</a> 4. 线程状态</h1><h2 id="操作系统线程五种状态" tabindex="-1"><a class="header-anchor" href="#操作系统线程五种状态" aria-hidden="true">#</a> 操作系统线程五种状态</h2><p><img src="'+d+'" alt=""></p><p><img src="'+u+'" alt=""></p><ul><li>【初始状态】（新建）：仅创建线程，未与操作系统线程关联；</li><li>【可运行状态】（就绪）：该线程已经被创建（与操作系统线程关联），可被CPU调度执行；</li><li>【运行状态】（执行）：获取CPU时间片运行中的状态； <ul><li>当CPU时间片用完，会从【运行状态】---&gt;【可运行状态】，导致线程上下文切换</li></ul></li><li>【阻塞状态】 <ul><li>若调用阻塞API，如BIO读取文件，该线程不会使用CPU，导致线程上下文切换，进入【阻塞状态】</li><li>等BIO操作完毕，会由操作西永唤醒阻塞的线程， 转至【可运行状态】</li><li>与【可运行状态】区别：【阻塞状态】的线程一直不唤醒，则调度器不会考虑调度这些线程</li></ul></li><li>【终止状态】：线程已经执行完毕，生命周期已经结束，不会转换成其他状态。</li></ul><h2 id="java线程六种状态" tabindex="-1"><a class="header-anchor" href="#java线程六种状态" aria-hidden="true">#</a> Java线程六种状态</h2><p><img src="'+l+'" alt=""></p>',7),m=a("li",null,"NEW：线程对象刚创建，未start；",-1),E=a("li",null,"RUNNABLE：调用start()方法后，注意：Java API层面的RUNNABLE状态涵盖操作系统层面【可运行状态】、【运行状态】和【阻塞状态】（由于BIO导致的线程阻塞在Java里无法区分，仍认为可运行）；",-1),B=a("li",null,"TERMINATED：当前线程代码运行结束。",-1);function A(f,I){const e=_("RouterLink");return s(),o("div",null,[p,a("ul",null,[m,E,a("li",null,[t("BLOCKED，WAITING，TIMED_WAITING是Java API层面对【阻塞状态】的细分，详情见"),r(e,{to:"/juc/3-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B/10.html"},{default:n(()=>[t("线程状态转换")]),_:1}),t("；")]),B])])}const x=i(h,[["render",A],["__file","4.html.vue"]]);export{x as default};
