import{_ as r}from"./2-92fe68ad.js";import{_ as t,V as o,W as i,$ as n}from"./framework-b9c3f338.js";const a="/study-note/juc/1.png",e={},s=n('<h1 id="_5-monitor概念" tabindex="-1"><a class="header-anchor" href="#_5-monitor概念" aria-hidden="true">#</a> 5. Monitor概念</h1><h2 id="java对象头" tabindex="-1"><a class="header-anchor" href="#java对象头" aria-hidden="true">#</a> Java对象头</h2><p><img src="'+a+'" alt=""></p><h2 id="monitor-锁" tabindex="-1"><a class="header-anchor" href="#monitor-锁" aria-hidden="true">#</a> Monitor（锁）</h2><p>每个Java对象都可关联一个Monitor对象，若使用sychronized给对象加（重量级）锁，该对象的对象头的Mark Word中被设置为指向Monitor对象的指针，该Monitor对象也称为<strong>管程</strong>或<strong>监视器锁</strong>。<br> 在HotSpot虚拟机中，Monitor是基于C++的<strong>ObjectMonitor类</strong>实现。</p><h2 id="monitor结构" tabindex="-1"><a class="header-anchor" href="#monitor结构" aria-hidden="true">#</a> Monitor结构</h2><p>EntryList：存放处于等待锁blocked状态的线程队列；<br> WaitSet：存放处于waiting状态的线程队列，即调用wait()方法的线程；<br> Owner：指向持有ObjectMonitor对象（锁）的线程。</p><p><img src="'+r+'" alt=""></p><ul><li>刚开始Monitor中的Owner为Null；</li><li>当Thread-1执行synchronized(obj)就会将Monitor的所有者Owner置为Thread-1，Monitor中只能有一个Owner；</li><li>在Thread-1上锁过程中，如果Thread-2、Thread-3、Thread-4也来执行synchronized(obj)就会进入EntryList BLOCKED；</li><li>Thread-1执行完同步代码块后，会唤醒EntryList中等待的线程来竞争锁，竞争是<strong>非公平的</strong>（即不遵守先进先得到锁的原则）；</li><li>WaitSet中的线程Thread-5、Thread-6是在其持有锁过程中使用wait()方法，进入waiting状态，需要另一个线程把它notify唤醒。</li></ul><div class="hint-container warning"><p class="hint-container-title">注意</p><p>synchronized必须是进入同一个对象的monitor才有上述效果；<br> 不加synchronized的对象不关联监视器，不遵从以上规则。</p></div><p>线程状态转换</p><p>活跃性</p><p>lock</p>',13),d=[s];function h(c,l){return o(),i("div",null,d)}const m=t(e,[["render",h],["__file","5.html.vue"]]);export{m as default};
