import{_ as n}from"./12-2bed3019.js";import{_ as a,V as i,W as l,$ as t}from"./framework-b9c3f338.js";const e={},r=t('<h1 id="_10-线程状态转换" tabindex="-1"><a class="header-anchor" href="#_10-线程状态转换" aria-hidden="true">#</a> 10. 线程状态转换</h1><p><img src="'+n+'" alt=""></p><h2 id="new-runnable" tabindex="-1"><a class="header-anchor" href="#new-runnable" aria-hidden="true">#</a> NEW --&gt; RUNNABLE</h2><ul><li>调用thread.start( )方法。</li></ul><h2 id="runnable-waiting" tabindex="-1"><a class="header-anchor" href="#runnable-waiting" aria-hidden="true">#</a> RUNNABLE &lt;--&gt; WAITING</h2><h3 id="【1】synchronized" tabindex="-1"><a class="header-anchor" href="#【1】synchronized" aria-hidden="true">#</a> 【1】synchronized</h3><ul><li>t线程synchronized(obj)获得对象锁后： <ul><li>调用obj.wait( ) 方法，t线程从 RUNNABLE --&gt; WAITING；</li><li>其他线程调用obj.notify( )，obj.notifyAll( )，t.interrupt( )来唤醒/打断线程t时，t线程重新开始竞争锁： <ul><li>竞争锁成功，t线程从 WAITING --&gt; RUNNABLE；</li><li>竞争锁失败，t线程从 WAITING --&gt; BLOCKED。</li></ul></li></ul></li></ul><h3 id="【2】join" tabindex="-1"><a class="header-anchor" href="#【2】join" aria-hidden="true">#</a> 【2】join</h3><ul><li>当前线程调用t.join( )时，当前线程从 RUNNABLE --&gt; WAITING； <ul><li>当前线程在t线程对象（锁是线程对象）的监视器上等待；</li></ul></li><li>t线程执行结束或调用当前线程 . interrupt( )时，当前线程从 WAITING --&gt; RUNNABLE。</li></ul><h3 id="【3】park" tabindex="-1"><a class="header-anchor" href="#【3】park" aria-hidden="true">#</a> 【3】park</h3><ul><li>当前线程先调用LockSupport.park( )方法，则RUNNABLE --&gt; WAITING；</li><li>其他线程调用LockSupport.unpark(当前线程对象)、当前线程对象 . interrupt( )，当前线程从 WAITING --&gt; RUNNABLE。</li></ul><h2 id="runnable-timed-waiting" tabindex="-1"><a class="header-anchor" href="#runnable-timed-waiting" aria-hidden="true">#</a> RUNNABLE &lt;--&gt; TIMED_WAITING</h2><h3 id="【1】wait-long-n" tabindex="-1"><a class="header-anchor" href="#【1】wait-long-n" aria-hidden="true">#</a> 【1】wait(long n)</h3><p>t线程synchronized(obj)获得对象锁后：</p><ul><li>调用obj.wait(long n) 方法，t线程从 RUNNABLE --&gt; TIMED_WAITING；</li><li>t线程等待超过n毫秒，或是其他线程调用obj.notify( )，obj.notifyAll( )，t.interrupt( )来唤醒/打断线程t时，t线程重新开始竞争锁： <ul><li>竞争锁成功，t线程从 TIMED_WAITING --&gt; RUNNABLE；</li><li>竞争锁失败，t线程从 TIMED_WAITING --&gt; BLOCKED。</li></ul></li></ul><h3 id="【2】join-long-n" tabindex="-1"><a class="header-anchor" href="#【2】join-long-n" aria-hidden="true">#</a> 【2】join(long n)</h3><ul><li>当前线程调用t.join(long n)时，当前线程从 RUNNABLE --&gt; TIMED_WAITING； <ul><li>当前线程在t线程对象（锁是线程对象）的监视器上等待；</li></ul></li><li>当前线程等待超过n毫秒后，或是t线程执行结束或调用当前线程 . interrupt( )时，当前线程从 TIMED_WAITING --&gt; RUNNABLE。</li></ul><h3 id="【3】sleep-long-n" tabindex="-1"><a class="header-anchor" href="#【3】sleep-long-n" aria-hidden="true">#</a> 【3】sleep(long n)</h3><ul><li>当前线程调用Thread.sleep(long n)，当前线程从 RUNNABLE --&gt; TIMED_WAITING；</li><li>当前线程睡眠超过n毫秒后，当前线程从 TIMED_WAITING --&gt; RUNNABLE。</li></ul><h3 id="【4】parknanos-long-nanos-或parkuntil-long-mills" tabindex="-1"><a class="header-anchor" href="#【4】parknanos-long-nanos-或parkuntil-long-mills" aria-hidden="true">#</a> 【4】parkNanos(long nanos)或parkUntil(long mills)</h3><ul><li>当前线程先调用LockSupport.parkNanos(long nanos)或LockSupport.parkUntil(long mills)方法，则RUNNABLE --&gt; TIMED_WAITING；</li><li>当前线程等待超过后，或是其他线程调用LockSupport.unpark(当前线程对象)、当前线程对象 . interrupt( )，当前线程从 TIMED_WAITING --&gt; RUNNABLE。</li></ul><h2 id="runnable-blocked" tabindex="-1"><a class="header-anchor" href="#runnable-blocked" aria-hidden="true">#</a> RUNNABLE &lt;--&gt; BLOCKED</h2><ul><li>t线程使用synchronized(obj)竞争锁时竞争失败，t线程从 RUNNABLE --&gt; BLOCKED；</li><li>持obj锁线程的同步代码块执行完毕，会唤醒该对象上所有BLOCKED的线程重新竞争，竞争成功的线程从BLOCKED --&gt; RUNNABLE ，竞争失败的线程仍是BLOCKED。</li></ul><h2 id="runnable-terminated" tabindex="-1"><a class="header-anchor" href="#runnable-terminated" aria-hidden="true">#</a> RUNNABLE &lt;--&gt; TERMINATED</h2><ul><li>当前线程所有代码执行完毕。</li></ul>',25),o=[r];function h(d,u){return i(),l("div",null,o)}const c=a(e,[["render",h],["__file","10.html.vue"]]);export{c as default};
