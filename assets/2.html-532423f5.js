import{_ as a,V as i,W as e,$ as l}from"./framework-b9c3f338.js";const n={},s=l(`<h1 id="_2-可见性" tabindex="-1"><a class="header-anchor" href="#_2-可见性" aria-hidden="true">#</a> 2. 可见性</h1><h2 id="volatile关键字" tabindex="-1"><a class="header-anchor" href="#volatile关键字" aria-hidden="true">#</a> volatile关键字</h2><ul><li><p>可保证可见性，不保证原子性，即可保证多个线程之间，一个线程对volatile变量的修改对另一个线程可见；</p><ul><li>仅用在一个写线程，多个读线程的情况；</li></ul></li><li><p>可修饰成员变量和静态成员变量，可避免线程从自己的工作内存中查找到变量的旧值，可拿到新值；</p></li><li><p>修改的数据必须立即写回主存；</p></li><li><p>根据CPU缓存一致性协议，某个CPU缓存写入内存（主内存）后（修改数据），其他CPU（运行的线程）通过总线嗅探到自己缓存值（工作内存）过期，就会把当前缓存设置为无效，从而从内存中获得最新值；</p></li><li><p>禁止指令重排序。</p></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="volatile不保证原子性分析" tabindex="-1"><a class="header-anchor" href="#volatile不保证原子性分析" aria-hidden="true">#</a> volatile不保证原子性分析</h3><ul><li><p>可保证线程能读取到写回的最新值，但不能保证读操作在写操作的后面，可能读到旧值；</p></li><li><p>i=0，两个线程对i进行i++，i++操作分为3步：读取i，i自增，写回i，可能出现的情况：</p><ol><li>读取i --- 线程2 线程内i=0</li><li>读取i --- 线程1 线程内i=0</li><li>i自增 --- 线程2 线程内i=1</li><li>写回i --- 线程2 静态变量i=1</li><li>i自增 --- 线程1 线程内i=1【此时线程1早已读取结束，线程2的写回只会影响主内存的值】</li><li>写回i --- 线程2 静态变量i=1</li></ol></li></ul><h2 id="synchronized" tabindex="-1"><a class="header-anchor" href="#synchronized" aria-hidden="true">#</a> synchronized</h2><ul><li><p>可保证代码块的原子性和代码块内变量的可见性，但其是重量级操作，性能相对较低；</p></li><li><p>线程在加锁时，先清空工作内存-&gt;在主内存中拷贝最新变量的副本到工作内存-&gt;执行完同步代码块-&gt;将更改后的共享变量的值刷新到主内存中-&gt;释放互斥锁。</p></li></ul>`,8),t=[s];function o(c,d){return i(),e("div",null,t)}const r=a(n,[["render",o],["__file","2.html.vue"]]);export{r as default};
