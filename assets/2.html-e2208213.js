import{_ as l,V as i,W as t,X as a,Y as n,Z as o,$ as s,C as r}from"./framework-b9c3f338.js";const d="/study-note/mysql/1.png",p="/study-note/mysql/2.png",c="/study-note/mysql/3.png",u="/study-note/mysql/4.png",h="/study-note/mysql/5.png",k="/study-note/mysql/6.png",m="/study-note/mysql/7.png",b="/study-note/mysql/8.png",v="/study-note/mysql/9.png",y="/study-note/mysql/10.png",_="/study-note/mysql/11.png",x="/study-note/mysql/12.png",g="/study-note/mysql/13.png",f="/study-note/mysql/14.png",w="/study-note/mysql/15.png",q="/study-note/mysql/16.png",S="/study-note/mysql/17.png",L="/study-note/mysql/18.png",I={},E=s('<h1 id="_2-msql进阶篇" tabindex="-1"><a class="header-anchor" href="#_2-msql进阶篇" aria-hidden="true">#</a> 2. MSQL进阶篇</h1><h2 id="_01-存储引擎" tabindex="-1"><a class="header-anchor" href="#_01-存储引擎" aria-hidden="true">#</a> 01 存储引擎</h2><h3 id="_1-mysql体系结构" tabindex="-1"><a class="header-anchor" href="#_1-mysql体系结构" aria-hidden="true">#</a> （1）mysql体系结构</h3><p><img src="'+d+'" alt=""></p><h4 id="【1】连接层" tabindex="-1"><a class="header-anchor" href="#【1】连接层" aria-hidden="true">#</a> 【1】连接层</h4><ul><li>负责客户端和链接服务，涉及连接处理、认证授权等。该层还有连接池。</li></ul><h4 id="【2】服务层" tabindex="-1"><a class="header-anchor" href="#【2】服务层" aria-hidden="true">#</a> 【2】服务层</h4><ul><li>完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解 析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。</li></ul><h4 id="【3】引擎层" tabindex="-1"><a class="header-anchor" href="#【3】引擎层" aria-hidden="true">#</a> 【3】引擎层</h4><ul><li>存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。数据库中的索引是在存储引擎层实现的。这些引擎是可插拔的。</li></ul><h4 id="【4】存储层" tabindex="-1"><a class="header-anchor" href="#【4】存储层" aria-hidden="true">#</a> 【4】存储层</h4><ul><li>将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询 日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。</li></ul><h3 id="_2-存储引擎简介" tabindex="-1"><a class="header-anchor" href="#_2-存储引擎简介" aria-hidden="true">#</a> （2）存储引擎简介</h3><ul><li>存储引擎是MYSQL核心部分，是<strong>存储数据、建立索引、更新/查询数据</strong>等技术的实现方式；</li><li>它是基于数据库表的，不是基于数据库的，存储引擎是表类型的；</li><li>创建表时可以指定存储引擎，在后面加上<code>ENGINE = InnoDB</code>即可；</li><li>查询当前数据库支持的存储引擎：<code>SHOW ENGINES;</code>；</li><li>查询表创建时的存储引擎：<code>SHOW CREATE TABLE XX;</code>；（默认是InnoDB）</li></ul><h3 id="_3-存储引擎特点" tabindex="-1"><a class="header-anchor" href="#_3-存储引擎特点" aria-hidden="true">#</a> （3）存储引擎特点</h3><h4 id="【1】innodb" tabindex="-1"><a class="header-anchor" href="#【1】innodb" aria-hidden="true">#</a> 【1】InnoDB</h4><ul><li><p>介绍：高可靠性和高性能的通用执行引擎，MySQL默认执行引擎；</p></li><li><p>特点：（事务、行锁、外键约束）</p><ul><li>DML操作遵循ACID模型，支持事务；</li><li>行级锁，提高并发访问性能；</li><li>支持外键约束，保证数据完整性和正确性。</li></ul></li><li><p>文件：</p><ul><li>xxx.ibd：xxx表示表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi【数据字典】）、数据和索引。 <ul><li>参数：<code>innodb_file_per_table</code>（多张表是否共用一个表空间，MYSQL8.0是开启的，每张表对应一个表空间） <ul><li>查询该参数：<code>show variables like &#39;innodb_file_per_table&#39;; </code></li></ul></li></ul></li></ul></li><li><p>逻辑存储结构：</p><ul><li>表空间： InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件；</li><li>段：表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管 理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区；</li><li>区：区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页；</li><li>页：页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区；</li><li>行：InnoDB存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段。</li></ul><p><img src="'+p+'" alt=""></p></li></ul><h4 id="【2】myisam" tabindex="-1"><a class="header-anchor" href="#【2】myisam" aria-hidden="true">#</a> 【2】MyISAM</h4><ul><li>介绍：MySQL早期的默认存储引擎。</li><li>特点： <ul><li>不支持事务，不支持外键；</li><li>支持表锁，不支持行锁；</li><li>访问速度快。</li></ul></li><li>文件：MYD、MYI、SDI文件。（数据、索引、表结构）</li></ul><h4 id="【3】memory" tabindex="-1"><a class="header-anchor" href="#【3】memory" aria-hidden="true">#</a> 【3】Memory</h4><ul><li>介绍：表表数据存储在内存中，智能作为临时表或缓存使用。</li><li>特点：内存存放、hash索引（默认）</li><li>文件：xx.sdi（表结构）</li></ul><h4 id="【4】对比" tabindex="-1"><a class="header-anchor" href="#【4】对比" aria-hidden="true">#</a> 【4】对比</h4><p><img src="'+c+'" alt=""></p><h4 id="【5】innodb与myisam区别" tabindex="-1"><a class="header-anchor" href="#【5】innodb与myisam区别" aria-hidden="true">#</a> 【5】InnoDB与MyISAM区别</h4><ul><li>InnoDB支持事务，MyISAM不支持；</li><li>InnoDB支持表锁和行锁，MyISAM只支持表锁，不支持行锁；</li><li>InnoDB支持外键约束，MyISAM不支持。</li></ul><h3 id="_4-存储引擎选择" tabindex="-1"><a class="header-anchor" href="#_4-存储引擎选择" aria-hidden="true">#</a> （4）存储引擎选择</h3><ul><li>InnoDB：适合有事务需求、在并发情况下要求一致性、除查询外有大量增删改操作的应用场景；</li><li>MyISAM：适合以读和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高的应用场景；</li><li>MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。</li></ul><h2 id="_02-索引" tabindex="-1"><a class="header-anchor" href="#_02-索引" aria-hidden="true">#</a> 02 索引</h2><h3 id="_1-索引概述" tabindex="-1"><a class="header-anchor" href="#_1-索引概述" aria-hidden="true">#</a> （1）索引概述</h3><ul><li><p>用来高效获取数据的数据结构（有序）。该数据结构以某种方式引用（指向）数据，可实现快速查找【类比目录】；</p></li><li><p>无索引，即全表扫描。</p></li><li><p>索引优点：</p><ul><li>提高数据检索效率，降低数据库IO成本；</li><li>通过索引对数据进行排序，江都数据排序成本，降低CPU消耗；</li></ul></li><li><p>索引缺点：</p><ul><li>索引列占用空间；</li><li>索引大大提高查询效率，但降低更新表的速度，对表进行增删改时，效率降低（要维护索引表）。</li></ul></li></ul><h3 id="_2-索引结构" tabindex="-1"><a class="header-anchor" href="#_2-索引结构" aria-hidden="true">#</a> （2）索引结构</h3><ul><li>MySQL的索引在存储引擎层实现。</li></ul><p><img src="'+u+'" alt=""></p><p><img src="'+h+'" alt=""></p><h4 id="【1】二叉树" tabindex="-1"><a class="header-anchor" href="#【1】二叉树" aria-hidden="true">#</a> 【1】二叉树</h4><ul><li>缺点是顺序插入时，会形成一个链表，查询性能大大降低。大数据量情况下，层次较深，检索速度慢；（可能树的高度过大）</li></ul><h4 id="【2】红黑树" tabindex="-1"><a class="header-anchor" href="#【2】红黑树" aria-hidden="true">#</a> 【2】红黑树</h4><ul><li>大数据量情况下，层次较深，检索速度慢。（可能树的高度过大）</li></ul><p><img src="'+k+'" alt=""></p><h4 id="【3】b-树-多路平衡二叉树" tabindex="-1"><a class="header-anchor" href="#【3】b-树-多路平衡二叉树" aria-hidden="true">#</a> 【3】B-树（多路平衡二叉树）</h4>',40),B=a("li",null,[n("m阶B-数满足的条件：（阶是每个节点孩子节点的个数） "),a("ul",null,[a("li",null,"每个节点最多有m个子节点，每个结点最多有m-1个关键字；"),a("li",null,"除了根节点和叶子节点之外，其他的每个节点最少有m/2（向上取整）个孩子节点；"),a("li",null,"根节点至少有两个孩子节点，即根结点最少有1个关键字；"),a("li",null,"所有的叶子节点都在同一层；"),a("li",null,"有k个子节点的父节点包含k - 1个关键码。")])],-1),M={href:"https://www.cs.usfca.edu/~galles/visualization/BTree.html",target:"_blank",rel:"noopener noreferrer"},Q=a("li",null,"TODO：B树与B+树内容待补充",-1),D=s('<p><img src="'+m+'" alt=""></p><h4 id="【4】b-树" tabindex="-1"><a class="header-anchor" href="#【4】b-树" aria-hidden="true">#</a> 【4】B+树</h4><ul><li>B+树与B树的区别： <ul><li>所有的数据出现在叶子结点，其他节点不保存数据，只用于索引；</li><li>所有的叶子节点形成一个单向链表；</li><li>如图：向上分裂时，3是数据会出现在叶子结点，也会作为索引放在根节点。</li></ul></li></ul><p><img src="'+b+'" alt=""></p><p><img src="'+v+'" alt=""></p><h4 id="【5】mysql的b-树" tabindex="-1"><a class="header-anchor" href="#【5】mysql的b-树" aria-hidden="true">#</a> 【5】MySQL的B+树</h4><ul><li>在原B+Tree的基础上，所有叶子结点变成循环双向链表，提高区间访问的性能，利于排序；</li></ul><p><img src="'+y+'" alt=""></p><h4 id="【6】hash索引" tabindex="-1"><a class="header-anchor" href="#【6】hash索引" aria-hidden="true">#</a> 【6】Hash索引</h4><ul><li><p>采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中；</p></li><li><p>hash冲突：多个键值映射到同一个槽位，可通过链表解决。</p></li><li><p>特点：</p><ul><li>存储时不按顺序，Hash索引只能用于对等比较(=，in)，不支持范围查询（between，&gt;，&lt; ，...）；</li><li>hash后结果是无序的，无法利用索引完成排序操作；</li><li>查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引。</li></ul></li><li><p>在MySQL中，支持hash索引的是Memory存储引擎。InnoDB中具有自适应hash功能，hash索引是 InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。</p></li></ul><h4 id="【7】innodb选择b-树索引结构的原因" tabindex="-1"><a class="header-anchor" href="#【7】innodb选择b-树索引结构的原因" aria-hidden="true">#</a> 【7】InnoDB选择B+树索引结构的原因</h4><ul><li>与二叉树相比，层数更低，搜索效率高；</li><li>与B-树相比，B-树的叶子结点与非叶子节点都会存储数据，导致一页中存储的键值变少，指针也跟着变少，同样要保存大量数据，就得增加树的高度，导致性能降低；MySQL的B+树还有个双向链表便于范围查找与排序；</li><li>hash支持等值匹配，但不支持范围匹配和排序操作。</li></ul><h3 id="_3-索引分类" tabindex="-1"><a class="header-anchor" href="#_3-索引分类" aria-hidden="true">#</a> （3）索引分类</h3><h4 id="【1】索引分类" tabindex="-1"><a class="header-anchor" href="#【1】索引分类" aria-hidden="true">#</a> 【1】索引分类</h4><p><img src="'+_+'" alt=""></p><h4 id="【2】聚簇索引与非聚簇索引" tabindex="-1"><a class="header-anchor" href="#【2】聚簇索引与非聚簇索引" aria-hidden="true">#</a> 【2】聚簇索引与非聚簇索引</h4><ul><li>InnoDB存储引擎中，根据索引存储形式分为：</li></ul><p><img src="'+x+'" alt=""></p><ul><li>聚簇索引选取规则： <ul><li>如果存在主键，主键索引就是聚簇索引；</li><li>不存在聚簇索引，就使用第一个唯一索引作为聚簇索引；</li><li>表没有主键，且没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</li></ul></li></ul><p><img src="'+g+'" alt=""></p><ul><li>聚簇索引的叶子节点是该行的数据；</li><li>非聚簇索引的叶子节点挂的是该字段值对应的主键值。</li></ul><p><img src="'+f+`" alt=""></p><ul><li>该SQL执行过程： <ul><li>根据name字段进行查询，且name是一个非聚簇索引，先在非聚簇索引中找到Arm所对应的主键是10；</li><li>由于查询的是*，则还需要根据主键值，在聚簇索引中找10对应的行（回表查询）；</li><li>拿到该行数据，返回。</li></ul></li><li>回表查询：先在非聚簇索引中查找数据，找到主键值，然后再到聚簇索引中根据主键值，获取数据。</li></ul><h3 id="_4-索引语法" tabindex="-1"><a class="header-anchor" href="#_4-索引语法" aria-hidden="true">#</a> （4）索引语法</h3><h4 id="【1】创建索引" tabindex="-1"><a class="header-anchor" href="#【1】创建索引" aria-hidden="true">#</a> 【1】创建索引</h4><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token punctuation">[</span> <span class="token keyword">UNIQUE</span> <span class="token operator">|</span> FULLTEXT <span class="token punctuation">]</span> <span class="token keyword">INDEX</span> index_name <span class="token keyword">ON</span> table_name <span class="token punctuation">(</span>index_col_name<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment"># 一般索引名是 idx_表名_字段1_字段2</span>
<span class="token keyword">create</span> <span class="token keyword">index</span> idx_user_name <span class="token keyword">on</span> tb_user<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="【2】查看索引" tabindex="-1"><a class="header-anchor" href="#【2】查看索引" aria-hidden="true">#</a> 【2】查看索引</h4><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SHOW</span> <span class="token keyword">INDEX</span> <span class="token keyword">FROM</span> table_name<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="【3】删除索引" tabindex="-1"><a class="header-anchor" href="#【3】删除索引" aria-hidden="true">#</a> 【3】删除索引</h4><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> index_name <span class="token keyword">ON</span> table_name<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_5-sql性能分析" tabindex="-1"><a class="header-anchor" href="#_5-sql性能分析" aria-hidden="true">#</a> （5）SQL性能分析</h3><h4 id="【1】sql执行频率" tabindex="-1"><a class="header-anchor" href="#【1】sql执行频率" aria-hidden="true">#</a> 【1】SQL执行频率</h4><ul><li>可查看当前数据库增删查改的频次；</li><li>如果该数据库以增删改为主，我们可以考虑不对其进行索引的优化；</li><li>如果该数据库以查询为主，则要考虑对数据库索引进行优化。</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code> <span class="token keyword">SHOW</span> <span class="token punctuation">[</span><span class="token keyword">SESSION</span><span class="token operator">|</span><span class="token keyword">GLOBAL</span><span class="token punctuation">]</span> <span class="token keyword">STATUS</span> <span class="token operator">LIKE</span> <span class="token string">&#39;Com_______&#39;</span><span class="token punctuation">;</span> <span class="token comment"># 7个_ </span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="`+w+`" alt=""></p><h4 id="【2】慢查询日志" tabindex="-1"><a class="header-anchor" href="#【2】慢查询日志" aria-hidden="true">#</a> 【2】慢查询日志</h4><ul><li>该日志记录所有执行时间操过指定参数（long_query_time，默认10s）的所有SQL语句的日志；</li><li>MySQL慢查询日志默认关闭；</li><li>开启MySQL慢查询日志：</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># 1. 修改配置文件（/etc/my.cnf））</span>
<span class="token comment"># 开启MySQL慢日志查询开关</span>
slow_query_log<span class="token operator">=</span><span class="token number">1</span>
<span class="token comment"># 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，该SQL语句就会被记录</span>
long_query_time<span class="token operator">=</span><span class="token number">2</span>

<span class="token comment"># 2. 重启MySQL</span>
systemctl restart mysqld

<span class="token comment"># 3. 重新登录MySQL查询</span>
<span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">&#39;slow_query_log&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>通过慢查询日志，可定位到执行效率比较低的SQL语句，并针对性进行优化。</li></ul><h4 id="【3】profile详情" tabindex="-1"><a class="header-anchor" href="#【3】profile详情" aria-hidden="true">#</a> 【3】profile详情</h4><ul><li>可以查看某个SQL语句具体执行过程中各阶段耗时情况；</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># 1. 查询MySQL是否支持profile</span>
<span class="token keyword">SELECT</span> @<span class="token variable">@hava_profiling</span><span class="token punctuation">;</span>

<span class="token comment"># 2. 查询profile是否开启</span>
<span class="token keyword">SELECT</span> @<span class="token variable">@profiling</span><span class="token punctuation">;</span>

<span class="token comment"># 3. 开启profile（可加session/global级别）</span>
<span class="token keyword">SET</span> @<span class="token variable">@profiling</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment"># 使用</span>
<span class="token comment"># 执行一系列SQL语句后...</span>
<span class="token comment">-- 查看每一条SQL的耗时情况（结果中有一列是query_id）</span>
<span class="token keyword">SHOW</span> PROFILES<span class="token punctuation">;</span>

<span class="token comment">-- 查看指定query_id的SQL语句各阶段耗时情况</span>
<span class="token keyword">SHOW</span> PROFILE <span class="token keyword">FOR</span> QUERY query_id<span class="token punctuation">;</span>

<span class="token comment">-- 查看指定query_id的SQL语句CPU的使用情况</span>
<span class="token keyword">SHOW</span> PROFILE CPU  <span class="token keyword">FOR</span> QUERY query_id<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="【4】explain" tabindex="-1"><a class="header-anchor" href="#【4】explain" aria-hidden="true">#</a> 【4】explain</h4><ul><li><p>EXPLAIN或DESC可获取MySQL在执行SELECT语句时的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 直接在select语句前加explain或desc</span>
<span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表名 <span class="token keyword">WHERE</span> 条件 <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p><img src="`+q+'" alt=""></p><p><img src="'+S+`" alt=""></p><ul><li>id主要是嵌套查询时，好几个SELECT语句进行排序执行；</li><li>type中： <ul><li>system：只有一条数据的系统表或衍生表只能有一条数据的主查询；</li><li>const：仅仅能查出一条的SQL语句并且用于Primary key 或 unique索引；</li><li>eq_ref：对于每个索引键的查询，返回匹配唯一行数据（有且只有1个，不能多，不能0）【唯一索引、主键索引】;</li><li>ref：非唯一性索引：对于每个索引键的查询，返回匹配的所有行（可以是0，或多个）</li><li>range：检索指定范围的行，查找一个范围内的数据；</li><li>index：查询索引中的全部数据； <ul><li>比如查找索引列的值：<code>select name,id from student;</code>，name是常规索引，不回表查询</li></ul></li><li>all：全表扫描。</li><li>filtered：查到的结果占查询过程中遍历的行数的百分比，越高越好。</li></ul></li></ul><h3 id="_6-索引使用" tabindex="-1"><a class="header-anchor" href="#_6-索引使用" aria-hidden="true">#</a> （6）索引使用</h3><h4 id="【1】单列索引与联合索引" tabindex="-1"><a class="header-anchor" href="#【1】单列索引与联合索引" aria-hidden="true">#</a> 【1】单列索引与联合索引</h4><ul><li>单列索引：一个索引只包含单个列；</li><li>联合索引：一个索引包含了多个列。（即在B+树中key值是多个列的值如(a,b)）</li><li>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引， 而非单列索引。</li></ul><h4 id="【2】最左前缀法则" tabindex="-1"><a class="header-anchor" href="#【2】最左前缀法则" aria-hidden="true">#</a> 【2】最左前缀法则</h4><ul><li>针对的联合索引；</li><li>最左前缀法则指的是查询从索引的最左列开始， 并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)，没有最左列就全部失效；</li><li>创建联合索引时，该索引为(a,b,c)：（创建索引先按a排序，再按b排序，最后按c排序） <ul><li>条件语句：<code>where a = xx</code>，只使用a索引，则索引只有(a)部分生效；</li><li>条件语句：<code>where a = xx and b = xx</code>，使用a,b，则索引只有(a,b)部分生效，c失效；</li><li>条件语句：<code>where a=xx and c = xx</code>，跳过了b列，则(a)生效，b,c部分失效；</li><li>条件语句：<code>where b = xx and c =xx</code>，没有a列即没有最左列，索引全部失效。</li><li>注意：a,b,c在where中顺序并不影响索引生效结果，<code>where a, b, c</code>与<code>where b,a,c</code>索引都为(a,b,c)；</li></ul></li><li>一般把查询最频繁的列作为联合索引的最左列；</li></ul><h4 id="【3】sql提示" tabindex="-1"><a class="header-anchor" href="#【3】sql提示" aria-hidden="true">#</a> 【3】SQL提示</h4><ul><li>一句SQL语句执行时可能能走好几种索引，MySQL会自动选择一个索引进行查询，但有时候我们又需要指定走某个索引，就需要SQL提示；</li><li>SQL提示：在SQL语句中加入一些人为的提示来达到优化操作的目的；</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">#  use index（建议该条语句走哪条索引，mysql内部还会再次进行评估）</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">use</span> <span class="token keyword">index</span><span class="token punctuation">(</span>idx_user_pro<span class="token punctuation">)</span> <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span><span class="token punctuation">;</span>

<span class="token comment"># ignore index（忽略指定的索引）</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">ignore</span> <span class="token keyword">index</span><span class="token punctuation">(</span>idx_user_pro<span class="token punctuation">)</span> <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span><span class="token punctuation">;</span>

<span class="token comment"># force index （强制使用某条索引）</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">force</span> <span class="token keyword">index</span><span class="token punctuation">(</span>idx_user_pro<span class="token punctuation">)</span> <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="【4】覆盖索引" tabindex="-1"><a class="header-anchor" href="#【4】覆盖索引" aria-hidden="true">#</a> 【4】覆盖索引</h4><ul><li><p>覆盖索引：创建一个索引，该索引包含查询中用到的所有字段；（主要是为了避免回表查询）</p></li><li><p>尽量使用覆盖索引，减少select *；</p></li><li><p>查询的字段最好是索引的字段（可包含主键值），因为走非聚簇索引时，就可以查找到对应字段，还可以查询到索引字段以及叶子节点上的主键值；</p></li><li><p>如果查询的字段包含非索引的字段，则还会通过主键值到聚簇索引中进行回表查询。</p></li><li><p>explain中Extra字段值解析：</p></li></ul><p><img src="`+L+`" alt=""></p><h4 id="【5】前缀索引" tabindex="-1"><a class="header-anchor" href="#【5】前缀索引" aria-hidden="true">#</a> 【5】前缀索引</h4><ul><li>主要针对字符串类型的字段作为索引，若都用原字符串作索引，会导致索引变得很大， 查询时，浪费大量的磁盘IO， 影响查询效率。因此可以把字符串的一部分前缀作为索引，节约索引空间，提高查询效率。</li><li>前缀长度根据选择性决定，选择性是指不重复的索引值（基数）和数据表的记录总数的比值，选择性越高查询效率越高，唯一索引的选择性为1；</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">index</span> idx_xxxx <span class="token keyword">on</span> 表名<span class="token punctuation">(</span> 字段名<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment"># 计算选择性</span>
<span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> email<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> tb_user <span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> substring<span class="token punctuation">(</span>email<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> tb_user <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_7-索引失效情况" tabindex="-1"><a class="header-anchor" href="#_7-索引失效情况" aria-hidden="true">#</a> （7）索引失效情况</h3><h4 id="【1】联合索引的最左前缀法则" tabindex="-1"><a class="header-anchor" href="#【1】联合索引的最左前缀法则" aria-hidden="true">#</a> 【1】联合索引的最左前缀法则</h4><ul><li>没有遵循最左前缀法则， 如没有添加最左列作为条件就使用联合索引会失败；</li></ul><h4 id="【2】联合索引中范围查找" tabindex="-1"><a class="header-anchor" href="#【2】联合索引中范围查找" aria-hidden="true">#</a> 【2】联合索引中范围查找</h4><ul><li>联合索引中，出现范围查询(&gt;,&lt;)，范围查询右侧的列索引失效；</li><li>解释：联合索引（a,b,c） <ul><li>索引值：(1,1,4) (1,2,0) (1,2,1) (1,2,2)</li><li><code>where a = 1 and b = 2 and c &lt; 2</code>：索引是按a先排序，在b排序，在c排序，a,b都是等值，获得的结果是有序的，然后可以对c进行范围查找；</li><li><code>where a= 1 and c &lt; 2 and b = 2</code>：虽然c是范围查找放在中间，但效果同上，是要看索引创建时的顺序，而非where中的顺序；</li><li><code>where a = 1 and b &lt;=2 and c = 1</code>：先按a=1,b&lt;=2查找结果，以上索引值都满足，但看c列(4,0,1,2)，变成无序，导致后面列索引失效；</li></ul></li></ul><h4 id="【3】在索引列上进行位列算" tabindex="-1"><a class="header-anchor" href="#【3】在索引列上进行位列算" aria-hidden="true">#</a> 【3】在索引列上进行位列算</h4><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> substring<span class="token punctuation">(</span>phone<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">&#39;15&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="【4】字符串类型不加引号" tabindex="-1"><a class="header-anchor" href="#【4】字符串类型不加引号" aria-hidden="true">#</a> 【4】字符串类型不加引号</h4><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> phone <span class="token operator">=</span> <span class="token string">&#39;17799990015&#39;</span><span class="token punctuation">;</span>

<span class="token comment"># phone列的索引失效（MySQL会隐式转换找值）</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> phone <span class="token operator">=</span> <span class="token number">17799990015</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="【5】模糊查询" tabindex="-1"><a class="header-anchor" href="#【5】模糊查询" aria-hidden="true">#</a> 【5】模糊查询</h4><ul><li>尾部模糊匹配，索引不失效；</li><li>头部模糊匹配。索引失效。</li></ul><h4 id="【6】or连接条件" tabindex="-1"><a class="header-anchor" href="#【6】or连接条件" aria-hidden="true">#</a> 【6】or连接条件</h4><ul><li>用or分开的条件，条件中的字段都有索引，就不会失效；</li><li>用or分开的条件，有一方条件中字段不是索引，那么其他条件中的字段即使是索引也不会生效。</li></ul><h4 id="【7】数据分布影响" tabindex="-1"><a class="header-anchor" href="#【7】数据分布影响" aria-hidden="true">#</a> 【7】数据分布影响</h4><ul><li>MySQL评估使用索引查询比全表查询慢，索引就会失效。</li><li>例如：is null 、is not null是否走索引，具体问题具体分析，看值的占比，分析哪个查询快。</li></ul><h3 id="_8-索引设计原则" tabindex="-1"><a class="header-anchor" href="#_8-索引设计原则" aria-hidden="true">#</a> （8）索引设计原则</h3><ul><li>针对于数据量较大，且查询比较频繁的表建立索引；</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引；</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高；</li><li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引；</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间， 避免回表，提高查询效率；</li><li>控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率；</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</li></ul>`,78);function O(N,T){const e=r("ExternalLinkIcon");return i(),t("div",null,[E,a("ul",null,[B,a("li",null,[n("m阶树添加操作时：会向上分裂。（"),a("a",M,[n("B-Tree Visualization (usfca.edu)"),o(e)]),n("）")]),Q]),D])}const C=l(I,[["render",O],["__file","2.html.vue"]]);export{C as default};
