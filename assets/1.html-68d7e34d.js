import{_ as o,V as r,W as s,X as e,Z as l,a0 as n,Y as a,$ as c,C as i}from"./framework-b9c3f338.js";const d="/study-note/jvm/5.png",_={},h=e("h1",{id:"_01-概述",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_01-概述","aria-hidden":"true"},"#"),a(" 01 概述")],-1),u=e("h2",{id:"运行时数据区",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#运行时数据区","aria-hidden":"true"},"#"),a(" 运行时数据区")],-1),f=e("li",null,"class文件通过类加载子系统加载、链接、初始化到运行时数据区，然后执行引擎执行运行时数据区中的数据。",-1),m=c('<p><img src="'+d+'" alt=""></p><h2 id="线程" tabindex="-1"><a class="header-anchor" href="#线程" aria-hidden="true">#</a> 线程</h2><ul><li>在Hotspot JVM中，每个线程与操作系统的本地线程直接映射（1:1）。即一个Java线程准备（程序计数器、虚拟方法栈、本地方法栈等）好执行后，一个操作系统的本地线程会同时创建。Java线程执行终止后，本地线程也会回收。</li><li>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功后，就会调用Java线程中的run()方法。</li></ul><h2 id="jvm系统线程" tabindex="-1"><a class="header-anchor" href="#jvm系统线程" aria-hidden="true">#</a> JVM系统线程</h2>',4);function C(p,v){const t=i("font");return r(),s("div",null,[h,u,e("ul",null,[f,e("li",null,[e("strong",null,[l(t,{color:"66CCOO"},{default:n(()=>[a("线程私有：程序计数器、虚拟方法栈、本地方法栈")]),_:1})]),a("。跟随线程的开始和结束而创建和销毁。")]),e("li",null,[e("strong",null,[l(t,{color:"66CCOO"},{default:n(()=>[a("线程共享：堆、方法区")]),_:1})]),a("。随着虚拟机的退出而销毁。")]),e("li",null,[e("strong",null,[l(t,{color:"66CCOO"},{default:n(()=>[a("一个Java应用程序即一个JVM只有一个Runtime实例，即运行时环境，对应一个运行时数据区。")]),_:1})])])]),m,e("p",null,[e("strong",null,[l(t,{color:"66CCOO"},{default:n(()=>[a("虚拟机线程，到安全点出现；周期任务线程；GC线程；编译线程；信号调度线程。")]),_:1})])])])}const O=o(_,[["render",C],["__file","1.html.vue"]]);export{O as default};
