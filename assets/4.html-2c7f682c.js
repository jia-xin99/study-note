import{_ as a,V as n,W as s,$ as e}from"./framework-b9c3f338.js";const l={},t=e(`<h1 id="_4-变量的线程安全分析" tabindex="-1"><a class="header-anchor" href="#_4-变量的线程安全分析" aria-hidden="true">#</a> 4. 变量的线程安全分析</h1><h2 id="成员变量与静态变量是否线程安全" tabindex="-1"><a class="header-anchor" href="#成员变量与静态变量是否线程安全" aria-hidden="true">#</a> 成员变量与静态变量是否线程安全</h2><ul><li>若都没共享，则线程安全</li><li>若都被共享，根据其状态是否改变，分为2种情况： <ul><li>若只是读操作，则线程安全</li><li>若有读写操作，则读写操作这段代码是临界区，需要考虑线程安全</li></ul></li></ul><h2 id="局部变量是否线程安全" tabindex="-1"><a class="header-anchor" href="#局部变量是否线程安全" aria-hidden="true">#</a> 局部变量是否线程安全</h2><ul><li>局部变量是基本数据类型或包装类，则线程安全</li><li>但局部变量引用的对象不一定是线程安全： <ul><li>若对象没有逃离方法的作用访问，则线程安全</li><li>若该对象逃离方法的作用范围，需要考虑线程安全</li></ul></li><li>举例： <ul><li>类A中method1中有局部变量list且调用method2，后续还有对list的读写操作；</li><li>list作为mehod2的参数，然后method2中会对该参数的读写操作</li><li>类A可被继承，method2不可被重写时（private）：method2没有新建线程，各个线程使用各自的list，不用考虑线程安全。</li><li>类A可被继承，m2thod2可被重写时（public）：类B继承A，它重写method2，其中有新建线程来读写list参数的操作，就会导致原本调用method1的线程与method2新建的线程对list都有读写操作，则要考虑线程安全。</li></ul></li><li>主要分析会不会出现多个线程对同一个对象（共享变量）有读写操作的情况。</li><li>私有和final在一定程度上可以保护线程安全。</li></ul><h2 id="常见线程安全类" tabindex="-1"><a class="header-anchor" href="#常见线程安全类" aria-hidden="true">#</a> 常见线程安全类</h2><h3 id="【1】线程安全类" tabindex="-1"><a class="header-anchor" href="#【1】线程安全类" aria-hidden="true">#</a> 【1】线程安全类</h3><ul><li>String，Integer，StringBuffer，Random，Vector，Hashtable，java.util.concurent包下的类。</li><li>举例：String类是final的，防止有子类重写其方法，其底层是一个final修饰的私有的char数组，subString方法是返回本身或新建一个新的对象给调用方，并没有对char数组进行修改的操作。</li><li>扩展：Spring中的类大部分都是单例的，需要考虑类中有状态对象的线程安全，无状态对象的线程安全不需要考虑。</li></ul><h3 id="【2】线程安全类的方法" tabindex="-1"><a class="header-anchor" href="#【2】线程安全类的方法" aria-hidden="true">#</a> 【2】线程安全类的方法</h3><ul><li>线程安全类的方法都是原子性（多个线程调用同一实例的同一方法是线程安全）；</li><li>线程安全类的方法组合不是原子性的，即可能出现线程不安全的情况。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Hashtable</span> table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hashtable</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 线程1，线程2</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>table<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;key&quot;</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	table<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;key&quot;</span><span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><ol><li>线程1执行get方法，线程2阻塞在get方法前；</li><li>线程1执行完，释放锁，线程2和线程1同时抢锁，线程2可能抢到锁；</li><li>线程2执行get方法，线程1阻塞在put方法前；</li><li>线程2执行完，释放锁，线程2和线程1同时抢锁，二者都可抢到锁，然后会依次put。</li><li>原本只想put一次key，目前put两次key，不是想要的结果。</li></ol></blockquote>`,12),i=[t];function o(c,p){return n(),s("div",null,i)}const r=a(l,[["render",o],["__file","4.html.vue"]]);export{r as default};
