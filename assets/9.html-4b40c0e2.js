import{_ as i,V as a,W as e,$ as l}from"./framework-b9c3f338.js";const s={},t=l('<h1 id="_9-mybatis缓存" tabindex="-1"><a class="header-anchor" href="#_9-mybatis缓存" aria-hidden="true">#</a> 9. Mybatis缓存</h1><h2 id="mybatis一级缓存" tabindex="-1"><a class="header-anchor" href="#mybatis一级缓存" aria-hidden="true">#</a> Mybatis一级缓存</h2><h3 id="【1】介绍" tabindex="-1"><a class="header-anchor" href="#【1】介绍" aria-hidden="true">#</a> 【1】介绍</h3><ul><li>一级缓存是<strong>SqlSession</strong>级别，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问。</li><li>Mybatis默认开启一级缓存。</li><li>一级缓存失效情况： <ul><li>不同的SqlSession对应不同的一级缓存；</li><li>同一个SqlSession但是查询条件不同；</li><li>同一个SqlSession两次查询期间执行了任何一次增删改操作；</li><li>同一个SqlSession两次查询期间手动清空了缓存。</li></ul></li></ul><h3 id="【2】原理" tabindex="-1"><a class="header-anchor" href="#【2】原理" aria-hidden="true">#</a> 【2】原理</h3><ul><li><p>一级缓存区域是根据SqlSession为单位划分的；</p></li><li><p>每次查询会先从缓存区域找，如果找不到从数据库查询，查询到数据将数据写入缓存；</p></li><li><p>Mybatis内部存储缓存使用一个<strong>HashMap</strong>，<strong>key为hashCode+sqlId+Sql语句</strong>，value为从查询出来映射生成的java对象；</p></li><li><p>sqlSession执行insert、update、delete等操作commit提交后会清空缓存区域。</p></li></ul><h2 id="mybatis二级缓存" tabindex="-1"><a class="header-anchor" href="#mybatis二级缓存" aria-hidden="true">#</a> Mybatis二级缓存</h2><h3 id="【1】介绍-1" tabindex="-1"><a class="header-anchor" href="#【1】介绍-1" aria-hidden="true">#</a> 【1】介绍</h3><ul><li><p>二级缓存是<strong>SqlSessionFactory</strong>级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存，即这些SqlSession共享此后若再次执行相同的查询语句，结果就会从缓存中获取；</p></li><li><p>二级缓存开启条件：</p><ul><li>在核心配置文件中，设置全局配置属性cacheEnabled=&quot;true&quot;，默认为true，不需要设置 ；</li><li>在映射文件中设置标签<code>&lt;cache/&gt;</code>，表明此Mapper开启二级缓存；</li><li>二级缓存必须在SqlSession关闭或提交之后有效；</li><li><strong>查询的数据所转换的实体类类型必须实现序列化的接口。</strong></li></ul></li><li><p>二级缓存失效的情况：</p><ul><li>两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效。</li></ul></li><li><p>一般不推荐开启二级缓存：<strong>涉及并发和事务问题。</strong></p></li></ul><h3 id="【2】原理-1" tabindex="-1"><a class="header-anchor" href="#【2】原理-1" aria-hidden="true">#</a> 【2】原理</h3><ul><li><p>二级缓存区域是根据mapper的namespace划分的；</p></li><li><p>每次查询会先从缓存区域找，如果找不到从数据库查询，查询到数据将数据写入缓存；</p></li><li><p>Mybatis内部存储缓存使用一个HashMap，key为hashCode+sqlId+Sql语句。value为从查询出来映射生成的java对象；</p></li><li><p>sqlSession执行insert、update、delete等操作commit提交后会清空缓存区域。</p></li></ul><h2 id="mybatis缓存查询的顺序" tabindex="-1"><a class="header-anchor" href="#mybatis缓存查询的顺序" aria-hidden="true">#</a> Mybatis缓存查询的顺序</h2><ul><li>先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用；</li><li>如果二级缓存没有命中，再查询一级缓存；</li><li>如果一级缓存也没有命中，则查询数据库；</li><li>SqlSession关闭之后，一级缓存中的数据会写入二级缓存。</li></ul><h2 id="mybatis整合第三方缓存ehcache" tabindex="-1"><a class="header-anchor" href="#mybatis整合第三方缓存ehcache" aria-hidden="true">#</a> Mybatis整合第三方缓存EHCache</h2><ul><li>用第三方缓存架构处理缓存的。</li></ul>',15),r=[t];function h(n,d){return a(),e("div",null,r)}const c=i(s,[["render",h],["__file","9.html.vue"]]);export{c as default};
