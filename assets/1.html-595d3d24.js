import{_ as i,V as e,W as a,$ as r}from"./framework-b9c3f338.js";const n={},l=r('<h1 id="_1-共享问题" tabindex="-1"><a class="header-anchor" href="#_1-共享问题" aria-hidden="true">#</a> 1. 共享问题</h1><h2 id="临界区" tabindex="-1"><a class="header-anchor" href="#临界区" aria-hidden="true">#</a> 临界区</h2><ul><li>一段代码块内存在对<strong>共享资源</strong>的多线程的读写操作，这段<strong>代码块</strong>即<strong>临界区</strong>。</li></ul><h2 id="竞态条件race-condition" tabindex="-1"><a class="header-anchor" href="#竞态条件race-condition" aria-hidden="true">#</a> 竞态条件Race Condition</h2><ul><li>多个线程在临界区内执行，由于代码执行序列不同导致结果无法预测，则称发生了竞态条件。（如多个线程对i进行i++）。</li></ul><h2 id="避免临界区竞态条件" tabindex="-1"><a class="header-anchor" href="#避免临界区竞态条件" aria-hidden="true">#</a> 避免临界区竞态条件</h2><ul><li>阻塞式方案：synchronized，Lock</li><li>非阻塞式方案：原子变量</li></ul><h2 id="互斥与同步" tabindex="-1"><a class="header-anchor" href="#互斥与同步" aria-hidden="true">#</a> 互斥与同步</h2><ul><li>互斥：保证临界区的竞态条件发生，同一时刻只有一个线程执行临界区代码； <ul><li>：使用 synchronized 或 Lock 达到共享资源互斥效果。</li></ul></li><li>同步：由于线程执行的先后顺序不同，需要一个线程等待其他线程运行到某个点； <ul><li>使用 wait/notify 或 Lock 的条件变量来达到线程间通信效果。</li></ul></li><li>都可通过synchronized完成。</li></ul>',9),t=[l];function o(d,h){return e(),a("div",null,t)}const s=i(n,[["render",o],["__file","1.html.vue"]]);export{s as default};
